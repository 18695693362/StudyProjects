<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-07-16 Sat 03:34 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="viewport" content="width=device-width, initial-scale=1" />
<title>Inside The C++ Object Model</title>
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Dong Guo" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="http://orgmode.org/org-manual.css" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Inside The C++ Object Model</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline14">1. Object Lessons</a>
<ul>
<li><a href="#orgheadline9">1.1. C++对象模型</a>
<ul>
<li><a href="#orgheadline1">1.1.1. 简单对象模型</a></li>
<li><a href="#orgheadline2">1.1.2. 表格对象驱动模型</a></li>
<li><a href="#orgheadline8">1.1.3. C++对象模型</a></li>
</ul>
</li>
<li><a href="#orgheadline10">1.2. 关键字带来的差异</a></li>
<li><a href="#orgheadline13">1.3. 对象的差异</a>
<ul>
<li><a href="#orgheadline11">1.3.1. 指针的类型</a></li>
<li><a href="#orgheadline12">1.3.2. OB 与 OO</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline35">2. The Semantics of Constructors</a>
<ul>
<li><a href="#orgheadline19">2.1. Default Constructor Construction</a>
<ul>
<li><a href="#orgheadline15">2.1.1. 成员类对象带有默认的构造函数</a></li>
<li><a href="#orgheadline16">2.1.2. 基类带有默认的构造函数</a></li>
<li><a href="#orgheadline17">2.1.3. 类带有一个或多个虚函数</a></li>
<li><a href="#orgheadline18">2.1.4. 类带有一个或多个虚基类</a></li>
</ul>
</li>
<li><a href="#orgheadline26">2.2. Copy Constructor Construction</a>
<ul>
<li><a href="#orgheadline20">2.2.1. 基于位的 copy 语义(Bitwise copy Semantics)</a></li>
<li><a href="#orgheadline25">2.2.2. 什么时候类不展现基于位的 copy 语义</a></li>
</ul>
</li>
<li><a href="#orgheadline33">2.3. 程序转化语义学</a>
<ul>
<li><a href="#orgheadline27">2.3.1. 明确的初始化操作</a></li>
<li><a href="#orgheadline28">2.3.2. 参数的初始化</a></li>
<li><a href="#orgheadline32">2.3.3. 返回值的初始化</a></li>
</ul>
</li>
<li><a href="#orgheadline34">2.4. 成员们的初始化列表</a></li>
</ul>
</li>
<li><a href="#orgheadline50">3. The Semantics of Data</a>
<ul>
<li><a href="#orgheadline36">3.1. 数据成员的绑定</a></li>
<li><a href="#orgheadline37">3.2. 数据成员的布局</a></li>
<li><a href="#orgheadline40">3.3. 数据成员的存取</a>
<ul>
<li><a href="#orgheadline38">3.3.1. 静态数据成员</a></li>
<li><a href="#orgheadline39">3.3.2. 非静态数据成员</a></li>
</ul>
</li>
<li><a href="#orgheadline45">3.4. 继承的数据成员</a>
<ul>
<li><a href="#orgheadline41">3.4.1. 没有多态的继承</a></li>
<li><a href="#orgheadline42">3.4.2. 加上多态以后</a></li>
<li><a href="#orgheadline43">3.4.3. 多重继承</a></li>
<li><a href="#orgheadline44">3.4.4. 虚拟继承</a></li>
</ul>
</li>
<li><a href="#orgheadline46">3.5. 数据成员的效率</a></li>
<li><a href="#orgheadline49">3.6. 指向数据成员的指针</a>
<ul>
<li><a href="#orgheadline47">3.6.1. 如何确定 vptr 是放在类的起始处还是尾端。</a></li>
<li><a href="#orgheadline48">3.6.2. 指向数据成员的指针的效率问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline67">4. The Semantics of Function</a>
<ul>
<li><a href="#orgheadline54">4.1. 成员函数的各种调用方式</a>
<ul>
<li><a href="#orgheadline51">4.1.1. 非静态成员函数</a></li>
<li><a href="#orgheadline52">4.1.2. 虚成员函数</a></li>
<li><a href="#orgheadline53">4.1.3. 静态成员函数</a></li>
</ul>
</li>
<li><a href="#orgheadline58">4.2. 虚拟成员函数</a>
<ul>
<li><a href="#orgheadline55">4.2.1. 无继承或单继承下的虚函数</a></li>
<li><a href="#orgheadline56">4.2.2. 多重继承下的虚函数</a></li>
<li><a href="#orgheadline57">4.2.3. 虚拟继承下的虚函数</a></li>
</ul>
</li>
<li><a href="#orgheadline59">4.3. 函数的效能</a></li>
<li><a href="#orgheadline63">4.4. 指向成员函数的指针</a>
<ul>
<li><a href="#orgheadline60">4.4.1. 支持指向虚成员函数的指针</a></li>
<li><a href="#orgheadline61">4.4.2. 多重继承下，指向成员函数的指针</a></li>
<li><a href="#orgheadline62">4.4.3. 指向成员函数之指针的效率</a></li>
</ul>
</li>
<li><a href="#orgheadline66">4.5. Inline Function</a>
<ul>
<li><a href="#orgheadline64">4.5.1. 形式参数</a></li>
<li><a href="#orgheadline65">4.5.2. 局部变量</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline77">5. Semantics of Construction,Destruction,and Copy</a>
<ul>
<li><a href="#orgheadline71">5.1. 无继承情况下的对象构造</a>
<ul>
<li><a href="#orgheadline68">5.1.1. Plain Ol' Data</a></li>
<li><a href="#orgheadline69">5.1.2. 抽象数据类型</a></li>
<li><a href="#orgheadline70">5.1.3. 包含虚函数</a></li>
</ul>
</li>
<li><a href="#orgheadline73">5.2. 继承体系下的对象构造</a>
<ul>
<li><a href="#orgheadline72">5.2.1. vptr 初始化语义</a></li>
</ul>
</li>
<li><a href="#orgheadline74">5.3. 对象复制语义</a></li>
<li><a href="#orgheadline75">5.4. 对象的效能</a></li>
<li><a href="#orgheadline76">5.5. 对象解构语义</a></li>
</ul>
</li>
<li><a href="#orgheadline85">6. Runtime Semantics</a>
<ul>
<li><a href="#orgheadline82">6.1. 对象的构造和解构</a>
<ul>
<li><a href="#orgheadline78">6.1.1. 全局对象</a></li>
<li><a href="#orgheadline79">6.1.2. 局部静态对象</a></li>
<li><a href="#orgheadline80">6.1.3. 对象数组</a></li>
<li><a href="#orgheadline81">6.1.4. 默认构造和数组</a></li>
</ul>
</li>
<li><a href="#orgheadline83">6.2. new delete 运算符</a></li>
<li><a href="#orgheadline84">6.3. 临时性对象</a></li>
</ul>
</li>
<li><a href="#orgheadline89">7. On the Cusp of the Object Model</a>
<ul>
<li><a href="#orgheadline86">7.1. 模板</a></li>
<li><a href="#orgheadline87">7.2. 异常处理</a></li>
<li><a href="#orgheadline88">7.3. 执行期类型识别</a></li>
</ul>
</li>
<li><a href="#orgheadline125">8. Q&amp;A:</a>
<ul>
<li><a href="#orgheadline101">8.1. c++中的类型转换有哪些？</a>
<ul>
<li><a href="#orgheadline90">8.1.1. 一、类型转换的意义：</a></li>
<li><a href="#orgheadline91">8.1.2. 二、什么是类型转换：</a></li>
<li><a href="#orgheadline100">8.1.3. 三、类型转换分类：</a></li>
</ul>
</li>
<li><a href="#orgheadline113">8.2. extern 和 static 的区别？</a>
<ul>
<li><a href="#orgheadline105">8.2.1. static</a></li>
<li><a href="#orgheadline112">8.2.2. extern</a></li>
</ul>
</li>
<li><a href="#orgheadline114">8.3. 字节对齐是什么？</a></li>
<li><a href="#orgheadline115">8.4. 内置类型变量在内存中如何布局？</a></li>
<li><a href="#orgheadline116">8.5. 类在内存中的布局是怎样的？</a></li>
<li><a href="#orgheadline117">8.6. 对象在内存中的布局是怎样的？</a></li>
<li><a href="#orgheadline118">8.7. 什么时候需要在成员函数中显式使用 this?</a></li>
<li><a href="#orgheadline121">8.8. 关于 inline 的问题</a>
<ul>
<li><a href="#orgheadline119">8.8.1. 什么时候使用 inline 什么时候不能使用 inline？</a></li>
<li><a href="#orgheadline120">8.8.2. 虚函数是否可以指定为 inline？</a></li>
</ul>
</li>
<li><a href="#orgheadline122">8.9. memcpy 和 memset 的使用</a></li>
<li><a href="#orgheadline123">8.10. virtual 机制和类对象、类指针、类引用</a></li>
<li><a href="#orgheadline124">8.11. Name Mangling</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
总的来说这本书讲了编译器在你的 C++代码上又做了哪些手脚？<br  />
</p>

<div id="outline-container-orgheadline14" class="outline-2">
<h2 id="orgheadline14"><span class="section-number-2">1</span> Object Lessons</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9"><span class="section-number-3">1.1</span> C++对象模型</h3>
<div class="outline-text-3" id="text-1-1">
<p>
c++有两种类数据成员：静态和非静态，以及三中类成员函数：静态，非静态以及虚函数。<br  />
如何模型出各种数据成员和函数成员呢？<br  />
</p>
</div>
<div id="outline-container-orgheadline1" class="outline-4">
<h4 id="orgheadline1"><span class="section-number-4">1.1.1</span> 简单对象模型</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<a href="res/lesson1_simple_object_model.png">Simple Object Model.png</a><br  />
一个对象是一系列的 slots，每个 slot 指向一个成员。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-4">
<h4 id="orgheadline2"><span class="section-number-4">1.1.2</span> 表格对象驱动模型</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<a href="res/lesson1_member_table_object_model.png">Member Table Object Model.png</a><br  />
把所有与成员相关的信息抽出来，放在一个数据成员表和一个成员函数表中。一个对象内含有指向这两个表格的指针。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8"><span class="section-number-4">1.1.3</span> C++对象模型</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
<a href="res/lesson1_c++_object_model.png">C++ Object Model.png</a><br  />
在此模型中，非静态数据成员被配置于每一个对象之内，静态数据成员则被放在所有对象之外，静态和非静态函数成员也被放在所有对象之外。虚函数通过下面<br  />
两个步骤支持：<br  />
</p>
<ol class="org-ol">
<li>每个类产生出一堆指向虚函数的指针，放在表格中。这个表被称为虚表。<br  /></li>
<li>每个类对象被添加一个指针，指向相关的虚表。通常这个指针被称为 vptr。vptr 的设定和重置都由每一个类的 constructor,destructor 和<br  /></li>
</ol>
<p>
copy assignment 运算符自动完成。每个类所关联的 type_info 对象也经由虚表被指出来，通常放在虚表的第一个 slot 处。<br  />
</p>

<p>
优缺点：<br  />
C++对象模型的主要缺点是，如果应用程序代码本身没有改变，只是用到的类的非静态数据成员有改变，这些应用程序的代码也需要重新编译。<br  />
表格对象驱动模型没有上述缺点，因为它提供了一层间接层，但是表格对象驱动模型空间和执行效率比较差。<br  />
</p>
</div>

<ol class="org-ol"><li><a id="orgheadline6"></a>加入继承<br  /><ol class="org-ol"><li><a id="orgheadline3"></a>简单对象模型<br  /><div class="outline-text-6" id="text-1-1-3-1-1">
<p>
简单对象模型中，每一个基类子对象可以由派生类内的一个 slot 指出。<br  />
</p>
</div></li>
<li><a id="orgheadline4"></a>基类表模型<br  /><div class="outline-text-6" id="text-1-1-3-1-2">
<p>
基表模型中，产生出一个基类表，表格中的每一个 slot 内含一个相关的 base class 地址。<br  />
每一个类对象内含有一个 bptr，它被初始化，指向其基表。<br  />
<a href="res/lesson1_base_class_tabel_model.png">Base Class Tabel Model.png</a><br  />
</p>
</div></li>
<li><a id="orgheadline5"></a>C++对象模型<br  /><div class="outline-text-6" id="text-1-1-3-1-3">
<p>
C++基类子对象的数据被直接放到派生类对象中。对于虚基类，则在类对象中为每个关联的虚基类对象加上一个指针。<br  />
</p>
</div></li></ol></li>
<li><a id="orgheadline7"></a>对象模型如何影响程序<br  /><div class="outline-text-5" id="text-1-1-3-2">
<p>
不同的对象模型，会导致“现有的程序代码必须修改”以及“必须加入新的程序代码”两个结果。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">foobar</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
   <span style="color: #ce537a; font-weight: bold;">X</span> *<span style="color: #7590db;">px</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">X</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">foo() is virtual function</span>
   xx.foo<span style="color: #bc6ec5;">()</span>;
   px-&gt;foo<span style="color: #bc6ec5;">()</span>;
   <span style="color: #4f97d7; font-weight: bold;">delete</span> px;
   <span style="color: #4f97d7; font-weight: bold;">return</span> xx; 
<span style="color: #4f97d7;">}</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ code</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foobar</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span> &amp;<span style="color: #7590db;">_result</span> <span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">construct _result</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">_result replaces local xx ...</span>
   _result.<span style="color: #a45bad;">X</span>::<span style="color: #7590db;">X</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">expand X *px = new X;</span>
   px = _new<span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #2d9574;">(</span> X <span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span> px != <span style="color: #a45bad;">0</span> <span style="color: #bc6ec5;">)</span>
      px-&gt;<span style="color: #a45bad;">X</span>::<span style="color: #7590db;">X</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">expand xx.foo(): suppress virtual mechanism</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">replace xx with _result</span>
   foo<span style="color: #bc6ec5;">(</span> &amp;_result <span style="color: #bc6ec5;">)</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">expand px-&gt;foo() using virtual mechanism</span>
   <span style="color: #bc6ec5;">(</span> *px-&gt;_vtbl<span style="color: #2d9574;">[</span> <span style="color: #a45bad;">2</span> <span style="color: #2d9574;">]</span> <span style="color: #bc6ec5;">)(</span> px <span style="color: #bc6ec5;">)</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">expand delete px;</span>
   <span style="color: #4f97d7; font-weight: bold;">if</span> <span style="color: #bc6ec5;">(</span> px != <span style="color: #a45bad;">0</span> <span style="color: #bc6ec5;">)</span> <span style="color: #bc6ec5;">{</span>
      <span style="color: #2d9574;">(</span> *px-&gt;_vtbl<span style="color: #67b11d;">[</span> <span style="color: #a45bad;">1</span> <span style="color: #67b11d;">]</span> <span style="color: #2d9574;">)(</span> px <span style="color: #2d9574;">)</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">destructor</span>
       _delete<span style="color: #2d9574;">(</span> px <span style="color: #2d9574;">)</span>;
   <span style="color: #bc6ec5;">}</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">replace named return statement</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">no need to destroy local object xx</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span>;
<span style="color: #4f97d7;">}</span>;
</pre>
</div>
</div></li></ol>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-3">
<h3 id="orgheadline10"><span class="section-number-3">1.2</span> 关键字带来的差异</h3>
<div class="outline-text-3" id="text-1-2">
<p>
在 C 所支持的 struct 和 C++所支持的 class 之间，有观念上的重要差异，但是，关键词本身并不提供这种差异。<br  />
C struct 在 C++中的一个合理用途，是当你需要传递“一个复杂的类对象的全部或部分”到某个 C 函数中去时，struct 声明可以将数据封装起来，并保证<br  />
拥有与 C 兼容的空间布局。这项保证只在组合的情况下才存在。如果是继承而不是组合，编译器会决定是否应该有额外的数据成员被安插到 base struct 子<br  />
对象中。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">1.3</span> 对象的差异</h3>
<div class="outline-text-3" id="text-1-3">
<p>
C++以下列方法支持多态：<br  />
</p>
<ol class="org-ol">
<li>经由一组隐含的转换操作。例如把一个派生类指针转化为一个指向其 public base type 的指针。<br  />
shape* ps = new circle();<br  /></li>
<li>经由 virtual function 机制：<br  />
ps-&gt;rotate();<br  /></li>
<li>经由 dynamic_cast 和 typeid 运算符：<br  />
if( circle* pc = dynamic_cast&lt;circle*&gt;(ps) ) &#x2026;<br  /></li>
</ol>
</div>
<div id="outline-container-orgheadline11" class="outline-4">
<h4 id="orgheadline11"><span class="section-number-4">1.3.1</span> 指针的类型</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
不同类型的指针，以内存需求的观点来说，没有什么不同。它们都需要足够的内存来放置一个机器地址。指向不同类型之各指针间的差异，既不在其指针表示法不同，<br  />
也不再其内容不同，而是在其所寻址出来的 object 类型不同。也就是说，“指针类型”会教导编译器如何解释某个特定地址中的内存内容及其大小。<br  />
一个 void*的指针不包含其所指对象类型的信息，所以只能够含有一个地址，而不能够通过它操作所指对象。<br  />
转型其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，它只影响“被指出之内存的大小和其内容”的解释方式。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">1.3.2</span> OB 与 OO</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
一个基于对象(object-based)的设计可能比一个对等的面向对象(OO)的设计速度更快而且空间更紧凑。速度快是因为所有的函数引发操作都在编译时期解析完<br  />
成，对象建构起来时不需要设置 virtual 机制；空间紧凑则是因为每个类对象不需要负担为了支持 virtual 机制而需要的额外负荷。不过，OB 设计比较没<br  />
有弹性。需要在弹性和效率之间进行权衡来进行取舍。<br  />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-2">
<h2 id="orgheadline35"><span class="section-number-2">2</span> The Semantics of Constructors</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19"><span class="section-number-3">2.1</span> Default Constructor Construction</h3>
<div class="outline-text-3" id="text-2-1">
<p>
什么时候才会合成出一个 Default Constructor? 当编译器需要的时候!而且，被合成出来的 constructor 只执行编译器所需要的行动。<br  />
对于类 X，如果没有任何用户定义的构造函数，会有一个默认的构造函数被声明。编译器不需要的默认构造函数被称为 trivial default constructor(无<br  />
用的默认构造函数)，由于编译器需要而由编译器合成的默认构造函数被称为 nontrivial default constructor(有用的默认构造函数)。<br  />
下面四种情况下，编译器需要合成默认构造函数：<br  />
</p>
</div>
<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15"><span class="section-number-4">2.1.1</span> 成员类对象带有默认的构造函数</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
如果一个类没有任何构造函数，但它内含一个成员对象，而这个成员对象有默认构造函数。那么编译器需要为此类合成出一个默认构造函数。不过这个合成操作只有<br  />
在默认构造函数被调用时才会发生。<br  />
如果一个类 A 有默认构造函数，它内含一个成员对象 b（类型为 class B），该成员对象也有默认构造函数，但是在类 A 的默认构造函数中，没有调用类 B<br  />
的默认构造函数。此时，编译器会扩展类 A 的默认构造函数，将对类 B 的默认构造函数调用插入进去。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">programmer defined default constructor</span>
<span style="color: #a45bad;">Bar</span>::<span style="color: #bc6ec5; font-weight: bold;">Bar</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span> str = <span style="color: #a45bad;">0</span>; <span style="color: #4f97d7;">}</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Augmented default constructor</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ Code</span>
<span style="color: #a45bad;">Bar</span>::<span style="color: #bc6ec5; font-weight: bold;">Bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   foo.<span style="color: #a45bad;">Foo</span>::Foo<span style="color: #bc6ec5;">()</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">augmented compiler code</span>
   str = <span style="color: #a45bad;">0</span>;        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">explicit user code</span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-4">
<h4 id="orgheadline16"><span class="section-number-4">2.1.2</span> 基类带有默认的构造函数</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类。那么编译器需要为此类合成出一个默认构造函数。它将调用上一层基类的默认构造函数。<br  />
如果类包含多个构造函数，但其中没有默认构造函数。那么编译器会扩展现有的每一个构造函数，将调用默认构造函数的程序代码加入进去。编译器不会合成一个新<br  />
的构造函数，因为有其他用户定义的构造函数存在。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-4">
<h4 id="orgheadline17"><span class="section-number-4">2.1.3</span> 类带有一个或多个虚函数</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
为了支持虚函数机制，编译器必须为每个含有虚函数类的对象设置虚指针（vptr）初值,放置适当的虚表地址。对于类所定义的每一个构造函数，编译器会安插<br  />
一些代码来做这样的事情。对于那些未声明任何构造函数的类，编译器会为它们合成一个默认构造函数，以便正确地初始化每一个类对象的 vptr。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-4">
<h4 id="orgheadline18"><span class="section-number-4">2.1.4</span> 类带有一个或多个虚基类</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
对于类所定义的每一个构造函数，编译器会安插那些“允许每一个 virtual base class 的执行期存取操作”的码。如果一个类没有任何构造函数，编译器<br  />
会为它们合成一个默认构造函数。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>: <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">i</span>; <span style="color: #4f97d7;">}</span>;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">A</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">X</span>   <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>: <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">j</span>; <span style="color: #4f97d7;">}</span>;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">B</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #4f97d7; font-weight: bold;">virtual</span> <span style="color: #ce537a; font-weight: bold;">X</span>   <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>: <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">d</span>; <span style="color: #4f97d7;">}</span>;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">C</span> : <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">A</span>, <span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">B</span> <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>: <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">k</span>; <span style="color: #4f97d7;">}</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">cannot resolve location of pa-&gt;X::i at compile-time</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">A</span>* <span style="color: #7590db;">pa</span> <span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span> pa-&gt;i = <span style="color: #a45bad;">1024</span>; <span style="color: #4f97d7;">}</span>
<span style="color: #bc6ec5; font-weight: bold;">main</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
   foo<span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">A</span> <span style="color: #bc6ec5;">)</span>;
   foo<span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">C</span> <span style="color: #bc6ec5;">)</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #4f97d7;">}</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754; foo &#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">possible compiler transformation</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">A</span>* <span style="color: #7590db;">pa</span> <span style="color: #4f97d7;">)</span> <span style="color: #4f97d7;">{</span> pa-&gt;__vbcX-&gt;i = <span style="color: #a45bad;">1024</span>; <span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26"><span class="section-number-3">2.2</span> Copy Constructor Construction</h3>
<div class="outline-text-3" id="text-2-2">
<p>
有三种情况，会以一个 object 的内容作为另一个类对象的初值：<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #4f97d7;">{</span> ... <span style="color: #4f97d7;">}</span>;
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#19968;&#31181;&#24773;&#20917;&#65292;&#26174;&#24335;&#29992;&#19968;&#20010;&#23545;&#35937;&#21021;&#22987;&#21270;&#21478;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">explicit initialization of one class object with another</span>
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span> = x;

<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x</span> <span style="color: #4f97d7;">)</span>;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
  <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#20108;&#31181;&#24773;&#20917;&#65292;&#38544;&#24335;&#21021;&#22987;&#21270;&#20989;&#25968;&#21442;&#25968;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">implicit initialization of foo()'s</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">first argument with xx</span>
  foo<span style="color: #bc6ec5;">(</span> xx <span style="color: #bc6ec5;">)</span>;
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... </span>
<span style="color: #4f97d7;">}</span>

<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">foo_bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
  <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;

  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#31532;&#19977;&#31181;&#24773;&#20917;&#65292;&#20989;&#25968;&#36820;&#22238;&#19968;&#20010;&#31867;&#23545;&#35937;</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...;</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> xx; 
<span style="color: #4f97d7;">}</span>
</pre>
</div>

<p>
如果类没有声明一个 copy constructor，就会有隐含的声明和隐含的定义。和以前一样 C++标准把 copy constructor 区分为 trivial 和<br  />
nontrivial 两种。只有 nontrivial 的实体才会被合成于程序中。<br  />
决定一个 copy constructor 是否为 nontrivial 的标准在于 class 是否展现出 bitwise copy semantics。<br  />
</p>
</div>
<div id="outline-container-orgheadline20" class="outline-4">
<h4 id="orgheadline20"><span class="section-number-4">2.2.1</span> 基于位的 copy 语义(Bitwise copy Semantics)</h4>
<div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#22768;&#26126;&#23637;&#29616;&#20102;&#22522;&#20110;&#20301;&#30340; copy &#35821;&#20041;</span>
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Word</span> <span style="color: #4f97d7;">{</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #bc6ec5; font-weight: bold;">Word</span><span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>* <span style="color: #bc6ec5;">)</span>;
   ~<span style="color: #bc6ec5; font-weight: bold;">Word</span><span style="color: #bc6ec5;">()</span> <span style="color: #bc6ec5;">{</span> <span style="color: #4f97d7; font-weight: bold;">delete</span> <span style="color: #2d9574;">[]</span> str; <span style="color: #bc6ec5;">}</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #4f97d7; font-weight: bold;">private</span>:
  <span style="color: #ce537a; font-weight: bold;">int</span>   <span style="color: #7590db;">cnt</span>;
  <span style="color: #ce537a; font-weight: bold;">char</span> *<span style="color: #7590db;">str</span>; 
<span style="color: #4f97d7;">}</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#22768;&#26126;&#27809;&#26377;&#23637;&#29616;&#20102;&#22522;&#20110;&#20301;&#30340; copy &#35821;&#20041;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">declaration does not exhibits bitwise copy semantics</span>
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Word</span> <span style="color: #4f97d7;">{</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #bc6ec5; font-weight: bold;">Word</span><span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">String</span>&amp; <span style="color: #bc6ec5;">)</span>;
   ~<span style="color: #bc6ec5; font-weight: bold;">Word</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #4f97d7; font-weight: bold;">private</span>:
   <span style="color: #ce537a; font-weight: bold;">int</span>    <span style="color: #7590db;">cnt</span>;
   <span style="color: #ce537a; font-weight: bold;">String</span> <span style="color: #7590db;">str</span>;
<span style="color: #4f97d7;">}</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">where String declares an explicit copy constructor:</span>
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">String</span> <span style="color: #4f97d7;">{</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #bc6ec5; font-weight: bold;">String</span><span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span> * <span style="color: #bc6ec5;">)</span>;
   <span style="color: #bc6ec5; font-weight: bold;">String</span><span style="color: #bc6ec5;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">String</span>&amp; <span style="color: #bc6ec5;">)</span>;
   ~<span style="color: #bc6ec5; font-weight: bold;">String</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #4f97d7;">}</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">In this case, the compiler needs to synthesize a copy constructor in order to invoke the</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">copy constructor of the member class String object:</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">A synthesized copy constructor</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ Code</span>
<span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #a45bad;">Word</span>::<span style="color: #bc6ec5; font-weight: bold;">Word</span><span style="color: #4f97d7;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Word</span>&amp; <span style="color: #7590db;">wd</span> <span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   str.<span style="color: #a45bad;">String</span>::<span style="color: #7590db;">String</span><span style="color: #bc6ec5;">(</span> wd.str <span style="color: #bc6ec5;">)</span>;
   cnt = wd.cnt;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">2.2.2</span> 什么时候类不展现基于位的 copy 语义</h4>
<div class="outline-text-4" id="text-2-2-2">
</div><ol class="org-ol"><li><a id="orgheadline21"></a>当类内含一个成员对象，而后者的类定义了一个 copy 构造函数。<br  /><div class="outline-text-5" id="text-2-2-2-1">
<p>
编译器需要将成员的 copy 构造调用操作安插到被合成的 copy 构造函数中。<br  />
</p>
</div></li>
<li><a id="orgheadline22"></a>当类继承自一个基类而后者存在有一个 copy constructor。<br  /><div class="outline-text-5" id="text-2-2-2-2">
<p>
编译器需要将基类的 copy 构造调用操作安插到被合成的 copy 构造函数中。<br  />
</p>
</div></li>
<li><a id="orgheadline23"></a>当类声明了一个或多个虚函数。<br  /><div class="outline-text-5" id="text-2-2-2-3">
<p>
编译器需要重新设定虚指针。<br  />
合成出来的类 A 的 copy 构造函数会明确设定对象的 vptr 指向类 A 的虚表，而不是直接从右手边的类对象中将其 vptr 直接 copy 过来。<br  />
(这样可以避免使用一个派生类对象来初始化基类对象时，基类对象的 vptr 错误指向派生类对象的虚表)<br  />
</p>
</div></li>
<li><a id="orgheadline24"></a>当类派生自一个继承串链，其中有一个或多个虚基类。<br  /><div class="outline-text-5" id="text-2-2-2-4">
<p>
编译器需要处理虚基类子对象。<br  />
</p>
</div></li></ol>
</div>
</div>
<div id="outline-container-orgheadline33" class="outline-3">
<h3 id="orgheadline33"><span class="section-number-3">2.3</span> 程序转化语义学</h3>
<div class="outline-text-3" id="text-2-3">
</div><div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">2.3.1</span> 明确的初始化操作</h4>
<div class="outline-text-4" id="text-2-3-1">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo_bar</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x1</span><span style="color: #bc6ec5;">(</span> x0 <span style="color: #bc6ec5;">)</span>;
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x2</span> = x0;
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x3</span> = x<span style="color: #bc6ec5;">(</span> x0 <span style="color: #bc6ec5;">)</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #4f97d7;">}</span>

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Possible program transformation</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ Code</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo_bar</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x1</span>; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#23450;&#20041;&#34987;&#37325;&#26032;&#65292;&#21021;&#22987;&#21270;&#25805;&#20316;&#34987;&#21093;&#31163;</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x2</span>; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#21516;&#19978;</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">x3</span>; <span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">&#21516;&#19978;</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler inserted invocations</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of copy constructor for X</span>
   x1.<span style="color: #a45bad;">X</span>::X<span style="color: #bc6ec5;">(</span> x0 <span style="color: #bc6ec5;">)</span>;
   x2.<span style="color: #a45bad;">X</span>::X<span style="color: #bc6ec5;">(</span> x0 <span style="color: #bc6ec5;">)</span>;
   x3.<span style="color: #a45bad;">X</span>::X<span style="color: #bc6ec5;">(</span> x0 <span style="color: #bc6ec5;">)</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... </span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline28" class="outline-4">
<h4 id="orgheadline28"><span class="section-number-4">2.3.2</span> 参数的初始化</h4>
<div class="outline-text-4" id="text-2-3-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
foo<span style="color: #4f97d7;">(</span> xx <span style="color: #4f97d7;">)</span>;

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ code</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler generated temporary</span>
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">__temp0</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler invocation of copy constructor</span>
__temp0.<span style="color: #a45bad;">X</span>::X <span style="color: #4f97d7;">(</span> xx <span style="color: #4f97d7;">)</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">rewrite function call to take temporary</span>
foo<span style="color: #4f97d7;">(</span> __temp0 <span style="color: #4f97d7;">)</span>;

&#24182;&#19988; foo &#20250;&#34987;&#20462;&#25913;&#20026;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">foo</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">x0</span> <span style="color: #4f97d7;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline32" class="outline-4">
<h4 id="orgheadline32"><span class="section-number-4">2.3.3</span> 返回值的初始化</h4>
<div class="outline-text-4" id="text-2-3-3">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">process xx ...</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span> xx;
<span style="color: #4f97d7;">}</span>

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">function transformation to reflect</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">application of copy constructor</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ Code</span>
<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #7590db;">__result</span> <span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler generated invocation</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of default constructor</span>
   xx.<span style="color: #a45bad;">X</span>::<span style="color: #7590db;">X</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... process xx</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler generated invocation</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">of copy constructor</span>
   __result.<span style="color: #a45bad;">X</span>::X<span style="color: #bc6ec5;">(</span> xx <span style="color: #bc6ec5;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">return</span>; 
<span style="color: #4f97d7;">}</span>

&#24182;&#19988;&#25152;&#26377;&#35843;&#29992; bar <span style="color: #ce537a; font-weight: bold;">&#30340;&#20989;&#25968;&#38656;&#35201;&#36827;&#34892;&#20462;&#25913;&#65306;</span>
<span style="color: #7590db;">&#24773;&#20917;</span> <span style="color: #a45bad;">1</span>
X xx = bar<span style="color: #4f97d7;">()</span>;
is transformed into the following <span style="color: #ce537a; font-weight: bold;">two</span> <span style="color: #7590db;">statements</span>:
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">note: no default constructor applied</span>
X xx;
bar<span style="color: #4f97d7;">(</span> xx <span style="color: #4f97d7;">)</span>;

&#24773;&#20917; <span style="color: #a45bad;">2</span>
bar<span style="color: #4f97d7;">()</span>.memfunc<span style="color: #4f97d7;">()</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compiler generated temporary</span>
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">__temp0</span>;
<span style="color: #4f97d7;">(</span> bar<span style="color: #bc6ec5;">(</span> __temp0 <span style="color: #bc6ec5;">)</span>, __temp0 <span style="color: #4f97d7;">)</span>.memfunc<span style="color: #4f97d7;">()</span>;

&#24773;&#20917; <span style="color: #a45bad;">3</span>
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #4f97d7;">(</span> *pf <span style="color: #4f97d7;">)(</span> <span style="color: #ce537a; font-weight: bold;">X</span>&amp; <span style="color: #4f97d7;">)</span>;
pf = bar;
</pre>
</div>
</div>
<ol class="org-ol"><li><a id="orgheadline31"></a>返回值优化<br  /><ol class="org-ol"><li><a id="orgheadline29"></a>在使用者层面做优化<br  /><div class="outline-text-6" id="text-2-3-3-1-1">
<p>
定义一个计算用的 constructor。这样可能导致计算用途的 construtor 大量扩散。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... process xx</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span> xx; 
<span style="color: #4f97d7;">}</span>
&#23558;&#19978;&#38754;&#30340;&#20195;&#30721;&#20889;&#20026;&#19979;&#38754;&#36825;&#31181;&#24418;&#24335;
<span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">T</span>&amp;<span style="color: #7590db;">y</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">T</span>&amp;<span style="color: #7590db;">z</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span> X<span style="color: #bc6ec5;">(</span>y, z<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
&#28982;&#21518;&#32534;&#35793;&#22120;&#20250;&#23558;&#20854;&#36716;&#21270;&#20026;
<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span> &amp;<span style="color: #7590db;">__result</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">T</span>&amp;<span style="color: #7590db;">y</span>, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">T</span>&amp;<span style="color: #7590db;">z</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   __result.<span style="color: #a45bad;">X</span>::<span style="color: #7590db;">X</span><span style="color: #bc6ec5;">(</span>y, z<span style="color: #bc6ec5;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">return</span>; 
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li>
<li><a id="orgheadline30"></a>在编译器层面做优化<br  /><div class="outline-text-6" id="text-2-3-3-1-2">
<p>
对于所有的 return 语句返回有名字对象的情况，编译器可以对其进行优化，方法为将返回值按照参数传递给该函数，这样的优化操作被称为 Named<br  />
Return Value 优化。<br  />
因为 Named Return Value 优化是为了避免 copy constructor 的调用，所以当用户没有定义类的 copy 构造函数时，该优化不会实施，<br  />
显式定义一个 copy 构造函数会激活 Named Return Value 优化。<br  />
Named Return Value 优化提供了重要的效率改善，也受到了一些批评，受到批评的原因有：<br  />
1 该优化由编译器默默完成，是否真的实施并不清楚。<br  />
2 一旦函数变得复杂，优化就变得比较难以实施，有可能该优化就不会实施。<br  />
3 该优化移除了函数内局部对象的构造和析构，改变了程序内容。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">X</span> <span style="color: #7590db;">xx</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... process xx</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span> xx; 
<span style="color: #4f97d7;">}</span>

&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;
<span style="color: #ce537a; font-weight: bold;">void</span>
<span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">X</span> &amp;<span style="color: #7590db;">__result</span> <span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">default constructor invocation</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Pseudo C++ Code</span>
   __result.<span style="color: #a45bad;">X</span>::<span style="color: #7590db;">X</span><span style="color: #bc6ec5;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">... process in __result directly</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span>; 
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li></ol></li></ol>
</div>
</div>
<div id="outline-container-orgheadline34" class="outline-3">
<h3 id="orgheadline34"><span class="section-number-3">2.4</span> 成员们的初始化列表</h3>
<div class="outline-text-3" id="text-2-4">
<p>
下列情况下，为了让你的程序能够被顺利编译，你必须使用 member initialization list:<br  />
1 当初始化一个引用成员时；<br  />
2 当初始化一个 const 成员时；<br  />
3 当调用一个基类的构造函数时，而它拥有一组参数；<br  />
4 当调用一个成员类的构造函数时，而它拥有一组参数；<br  />
</p>

<p>
编译器会对初始化列表一一处理并可能重新排序，以反映出成员在类的声明顺序，它会将初始化操作安插到构造函数体内，并置于任何显式的用户代码之前。<br  />
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline50" class="outline-2">
<h2 id="orgheadline50"><span class="section-number-2">3</span> The Semantics of Data</h2>
<div class="outline-text-2" id="text-3">
<p>
影响类对象大小的三个因素：<br  />
1 语言本身所造成的额外负担。由于支持某些语言特性（主要是各种 virtual 特性），编译器自动加上了额外的数据成员。<br  />
2 编译器对特殊情况提供的优化处理<br  />
3 Alignment 的限制<br  />
</p>
</div>

<div id="outline-container-orgheadline36" class="outline-3">
<h3 id="orgheadline36"><span class="section-number-3">3.1</span> 数据成员的绑定</h3>
<div class="outline-text-3" id="text-3-1">
<p>
对成员函数本身的分析，会直到整个类的声明都出现了才开始。但是对于成员函数的参数列表并不是这样的，参数列表中的名称还是会在它们第一次被遇到时被适当<br  />
地决议完成。所以，应该将嵌套在类内的类型声明放置在类的起始位置。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline37" class="outline-3">
<h3 id="orgheadline37"><span class="section-number-3">3.2</span> 数据成员的布局</h3>
<div class="outline-text-3" id="text-3-2">
<p>
静态数据成员存放在程序的数据段中，和个别的类对象无关。<br  />
C++标准要求，在同一个 access section 中，成员的排列只需符合较晚出现的成员在类对象中有较高的地址。也就是说各个成员并不一定得连续排列。<br  />
成员变量之间可能会由于字节对齐而填充一些字节。<br  />
编译器合成的内部数据成员，可能会放置在对象的最后，也可能放在最前，对此 C++标准并没有规定。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#30340;&#20195;&#30721;&#21487;&#20197;&#21028;&#26029;&#31867;&#25104;&#21592;&#30340;&#20986;&#29616;&#39034;&#24207;</span>
<span style="color: #4f97d7; font-weight: bold;">template</span><span style="color: #4f97d7;">&lt;</span> <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">class_type</span>,
          <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">data_type1</span>,
          <span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">data_type2</span> <span style="color: #4f97d7;">&gt;</span>
<span style="color: #ce537a; font-weight: bold;">char</span>*
<span style="color: #bc6ec5; font-weight: bold;">access_order</span><span style="color: #4f97d7;">(</span>
   <span style="color: #ce537a; font-weight: bold;">data_type1</span> <span style="color: #a45bad;">class_type</span>::*<span style="color: #7590db;">mem1</span>,
   <span style="color: #ce537a; font-weight: bold;">data_type2</span> <span style="color: #a45bad;">class_type</span>::*<span style="color: #7590db;">mem2</span> <span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
   assert <span style="color: #bc6ec5;">(</span> mem1 != mem2 <span style="color: #bc6ec5;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">return</span>
      mem1 &lt; mem2
         ? <span style="color: #2d9574;">"member 1 occurs first"</span>
         : <span style="color: #2d9574;">"member 2 occurs first"</span>;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline40" class="outline-3">
<h3 id="orgheadline40"><span class="section-number-3">3.3</span> 数据成员的存取</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38"><span class="section-number-4">3.3.1</span> 静态数据成员</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
每一个静态数据成员只有一个实体，存放在程序的数据段之中，每次程序取用静态数据成员，就会被内部转化为对该唯一的 extern 实体的直接参考操作。<br  />
对一个静态数据成员取地址，会得到一个指向其数据类型的指针，而不是一个指向类成员的指针。<br  />
编译器会对每个静态数据成员编码（name-mangling）,从而获得一个独一无二的名称，避免重名。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">3.3.2</span> 非静态数据成员</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
非静态数据成员直接存放在每一个类对象之中。对一个非静态数据成员进行存取操作，编译器需要把类对象的起始地址加上数据成员的偏移量。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp">origin._y = <span style="color: #a45bad;">0</span>.<span style="color: #a45bad;">0</span>;
&#37027;&#20040;&#22320;&#22336;&amp;origin._y &#23558;&#31561;&#20110; &amp;origin+<span style="color: #4f97d7;">(</span>&amp;<span style="color: #a45bad;">Point3d</span>::y-<span style="color: #a45bad;">1</span><span style="color: #4f97d7;">)</span>;
<span style="color: #ce537a; font-weight: bold;">Tips&#65306;</span>
<span style="color: #7590db;">&#25351;&#21521;&#25968;&#25454;&#25104;&#21592;&#30340;&#25351;&#38024;</span>&#65292;&#20854;&#20540;&#24635;&#26159;&#34987;&#21152;&#19978; 1&#65292;&#36825;&#26679;&#21487;&#20197;&#20351;&#32534;&#35793;&#31995;&#32479;&#21306;&#20998;&#8220;&#19968;&#20010;&#25351;&#21521;&#25968;&#25454;&#25104;&#21592;&#30340;&#25351;&#38024;&#65292;&#29992;&#20197;&#25351;&#20986;&#31867;&#30340;&#31532;&#19968;&#20010;&#25104;&#21592;&#8221;&#21644;&#8220;&#19968;&#20010;&#25351;&#21521;&#25968;&#25454;&#25104;&#21592;&#30340;&#25351;&#38024;&#65292;
&#27809;&#26377;&#25351;&#20986;&#20219;&#20309;&#25104;&#21592;&#20004;&#31181;&#24773;&#20917;&#8221;&#12290;
</pre>
</div>
<p>
每一个非静态数据成员的偏移量在编译时期即可获得，甚至该成员属于一个基类子对象。所以存取一个非静态数据成员，其效率和存取一个 C 结构体成员<br  />
或一个没有继承的成员是一样的。<br  />
如果非静态数据成员为一个虚基类成员，那么通过指针对该成员的存取速度回变慢。因为无法确定指针必然指向哪种类类型，所以这个存取操作必须延迟到<br  />
执行期，经由一个额外的间接引导，才能够解决。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline45" class="outline-3">
<h3 id="orgheadline45"><span class="section-number-3">3.4</span> 继承的数据成员</h3>
<div class="outline-text-3" id="text-3-4">
<p>
C++标准没有强制指定派生类成员和基类成员的排列次序。大部分编译器，基类成员总是先出现，但虚基类除外。<br  />
</p>
</div>
<div id="outline-container-orgheadline41" class="outline-4">
<h4 id="orgheadline41"><span class="section-number-4">3.4.1</span> 没有多态的继承</h4>
<div class="outline-text-4" id="text-3-4-1">
<p>
把一个类分解为两层或者更多层，有可能会为了表现类体系之抽象化而膨胀所需空间。因为 C++语言保证出现在派生类中的基类子对象有其完整原样性。<br  />
Tips:<br  />
具体信息需要看原书中举的实例。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline42" class="outline-4">
<h4 id="orgheadline42"><span class="section-number-4">3.4.2</span> 加上多态以后</h4>
<div class="outline-text-4" id="text-3-4-2">
<p>
支持多态后产生的额外负担：<br  />
1 导入一个和 Point2d 相关的虚表，用来存放它所声明的每一个虚函数地址。这个虚表的元素数目一般而言是被声明的虚函数的数目，再加上一个或两<br  />
个 slots(用以支持 runtime type identification)<br  />
2 在每一个类对象中导入一个 vptr，提供执行期的链接，使每一个对象能够找到相应的虚表。<br  />
3 加强 constructor，使它能够为 vptr 设定初值，让它指向所对应的虚表。<br  />
4 加强 destructor，使它能够抹消指向类之相关虚表的指针。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline43" class="outline-4">
<h4 id="orgheadline43"><span class="section-number-4">3.4.3</span> 多重继承</h4>
<div class="outline-text-4" id="text-3-4-3">
<p>
1 多重继承的问题主要发生于派生类对象和其第二或后继基类对象之间的转换。<br  />
对一个多重派生对象，将其地址指定给最左端（也就是第一个）基类的指针，情况将和单一继承相同，因为二者都指向相同的起始地址。<br  />
至于第二或后继基类的地址指定操作，则需要将地址进行修改，加上（或减去，如果 downcast 的话）介于中间的子类对象的大小。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">Vertex3d</span> <span style="color: #7590db;">v3d</span>;
<span style="color: #ce537a; font-weight: bold;">Vertex</span>  *<span style="color: #7590db;">pv</span>;
<span style="color: #ce537a; font-weight: bold;">Point2d</span> *<span style="color: #7590db;">pp</span>;
<span style="color: #ce537a; font-weight: bold;">Point3d</span> *<span style="color: #7590db;">p3d</span>;

pv = &amp;v3d;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721; Pseudo C++ Code</span>
pv = <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Vertex</span>*<span style="color: #4f97d7;">)(</span><span style="color: #bc6ec5;">(</span><span style="color: #2d9574;">(</span><span style="color: #ce537a; font-weight: bold;">char</span>*<span style="color: #2d9574;">)</span>&amp;v3d<span style="color: #bc6ec5;">)</span> + <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #bc6ec5;">(</span> Point3d <span style="color: #bc6ec5;">)</span><span style="color: #4f97d7;">)</span>;

pv = p3d;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721; Pseudo C++ Code</span>
pv = p3d
   ? <span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">Vertex</span>*<span style="color: #4f97d7;">)(</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">char</span>*<span style="color: #bc6ec5;">)</span>p3d<span style="color: #4f97d7;">)</span> + <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #4f97d7;">(</span> Point3d <span style="color: #4f97d7;">)</span>
   : <span style="color: #a45bad;">0</span>;
</pre>
</div>
<p>
2 对于第二或后继基类中的数据成员的存储是不需要付出额外成本的，因为成员的位置在编译时就固定下了，因此存取成员只是一个简单的 offset 运算。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline44" class="outline-4">
<h4 id="orgheadline44"><span class="section-number-4">3.4.4</span> 虚拟继承</h4>
<div class="outline-text-4" id="text-3-4-4">
<p>
类如果内含一个或多个虚基类子对象，将被分割为两个部分：一个不变局部和一个共享局部。不变局部中的数据，不管后继如何衍化，总是拥有固定的 offset（从<br  />
对象的开头算起），所以这部分数据可以被直接存取。至于共享局部，所表现的就是虚拟基类子对象。这部分数据，其位置会因为每次的派生操作而有变化，所以他<br  />
们只可以被间接存取。一般的布局策略是先安排好派生类的不变部分，然后再建立其共享部分。<br  />
通过对象对虚基类中的数据成员的存取可以被优化为一个直接存取操作。<br  />
Tips:<br  />
原书中描述了几种实现方式，具体细节需要看原书。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline46" class="outline-3">
<h3 id="orgheadline46"><span class="section-number-3">3.5</span> 数据成员的效率</h3>
<div class="outline-text-3" id="text-3-5">
<p>
具体细节看原书吧<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline49" class="outline-3">
<h3 id="orgheadline49"><span class="section-number-3">3.6</span> 指向数据成员的指针</h3>
<div class="outline-text-3" id="text-3-6">
<p>
指向数据成员的指针表示了该成员在类对象中的偏移量。<br  />
</p>
</div>
<div id="outline-container-orgheadline47" class="outline-4">
<h4 id="orgheadline47"><span class="section-number-4">3.6.1</span> 如何确定 vptr 是放在类的起始处还是尾端。</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
定义一个类其中放置两个数据成员，不包含虚函数，打印类成员变量的指针。为这个类定义一个虚函数，再次打印成员变量的指针。如果有变化说明 vptr 被放<br  />
在了类的起始地址，如果没有变化说明 vptr 被放在类成员的末尾了。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">3.6.2</span> 指向数据成员的指针的效率问题</h4>
<div class="outline-text-4" id="text-3-6-2">
<p>
以指向成员的指针来存取数据会导致效率变慢。<br  />
具体细节看原书吧。<br  />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline67" class="outline-2">
<h2 id="orgheadline67"><span class="section-number-2">4</span> The Semantics of Function</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-orgheadline54" class="outline-3">
<h3 id="orgheadline54"><span class="section-number-3">4.1</span> 成员函数的各种调用方式</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51"><span class="section-number-4">4.1.1</span> 非静态成员函数</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
C++的设计准则之一就是非静态成员函数至少和一般的非成员函数有相同的效率。选择成员函数不应该带来什么额外的负担。<br  />
成员函数被内化为非成员函数，转化步骤如下：<br  />
</p>

<p>
1 改写函数的签名以安插一个额外的参数到成员函数中，用以提供一个存取管道，使类对象得以调用该函数。该额外参数被称为 this 指针。<br  />
</p>

<p>
2 将“每一个对非静态数据成员的存取操作”改为“经由 this 指针来存取”<br  />
3 将成员函数重新写成一个外部函数。对函数名称进行 mangling 处理，使它在程序中成为独一无二的语汇<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp">&#21407;&#22987;&#25104;&#21592;&#20989;&#25968;
<span style="color: #ce537a; font-weight: bold;">Point3d</span> <span style="color: #a45bad;">Point3d</span>::<span style="color: #bc6ec5; font-weight: bold;">magnitude</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #4f97d7; font-weight: bold;">return</span> sqrt<span style="color: #bc6ec5;">(</span>
         _x * _x + _y * _y + _z * _z
   <span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
step <span style="color: #a45bad;">1</span>
Point3d <span style="color: #a45bad;">Point3d</span>::magnitude<span style="color: #4f97d7;">(</span> <span style="color: #ce537a; font-weight: bold;">Point3d</span> *<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #4f97d7;">)</span>
<span style="color: #ce537a; font-weight: bold;">Point3d</span> <span style="color: #a45bad;">Point3d</span>::<span style="color: #bc6ec5; font-weight: bold;">magnitude</span><span style="color: #4f97d7;">(</span> <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">Point3d</span> *<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #4f97d7;">)</span>
step <span style="color: #a45bad;">2</span>
<span style="color: #4f97d7;">{</span>
  <span style="color: #4f97d7; font-weight: bold;">return</span> sqrt<span style="color: #bc6ec5;">(</span>
    <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_x * <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_x +
    <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_y * <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_y +
    <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_z * <span style="color: #4f97d7; font-weight: bold;">this</span>-&gt;_z <span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
step <span style="color: #a45bad;">3</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> magnitude__7Point3dFv<span style="color: #4f97d7;">(</span> <span style="color: #4f97d7; font-weight: bold;">register</span> <span style="color: #ce537a; font-weight: bold;">Point3d</span> *<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #4f97d7; font-weight: bold;">this</span> <span style="color: #4f97d7;">)</span>;

<span style="color: #ce537a; font-weight: bold;">&#20195;&#30721;&#20013;&#30340;&#36716;&#21270;</span>
<span style="color: #bc6ec5; font-weight: bold;">obj</span>.magnitude<span style="color: #4f97d7;">()</span>; &#21464;&#20026; <span style="color: #ce537a; font-weight: bold;">magnitude__7Point3dFv</span><span style="color: #4f97d7;">(</span> &amp;<span style="color: #7590db;">obj</span> <span style="color: #4f97d7;">)</span>;
ptr-&gt;magnitude<span style="color: #4f97d7;">()</span>; <span style="color: #ce537a; font-weight: bold;">&#21464;&#20026;</span> <span style="color: #bc6ec5; font-weight: bold;">magnitude__7Point3dFv</span><span style="color: #4f97d7;">(</span> ptr <span style="color: #4f97d7;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline52" class="outline-4">
<h4 id="orgheadline52"><span class="section-number-4">4.1.2</span> 虚成员函数</h4>
<div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">

<pre class="src src-cpp">ptr-&gt;normalize<span style="color: #4f97d7;">()</span>;
&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;
<span style="color: #4f97d7;">(</span> * ptr-&gt;vptr<span style="color: #bc6ec5;">[</span> <span style="color: #a45bad;">1</span> <span style="color: #bc6ec5;">]</span><span style="color: #4f97d7;">)(</span> ptr <span style="color: #4f97d7;">)</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">4.1.3</span> 静态成员函数</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
对一个静态成员函数取地址获得的是这个函数在内存中的地址。由于静态成员函数没有 this 指针，所以其地址的类型并不是一个指向类成员函数的指针。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline58" class="outline-3">
<h3 id="orgheadline58"><span class="section-number-3">4.2</span> 虚拟成员函数</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55"><span class="section-number-4">4.2.1</span> 无继承或单继承下的虚函数</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
这一节原书讲的很精彩，看原书内容吧<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline56" class="outline-4">
<h4 id="orgheadline56"><span class="section-number-4">4.2.2</span> 多重继承下的虚函数</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
在多重继承下支持虚函数，其复杂度围绕在第二个即后继的 base 类身上，以及必须在执行期调整 this 指针这一点上。<br  />
在多重继承下，一个派生类内含有多个额外的虚函数表。所以，虚表指针成员也需要 name mangling 技术。<br  />
有三种情况，第二或后继的 base class 会影响对虚函数的支持。<br  />
1 通过一个指向第二基类的指针，调用派生类虚函数。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">Base2</span> *<span style="color: #7590db;">ptr</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Derived</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">invokes Derived::~Derived</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">ptr must be adjusted backward by sizeof( Base1 )</span>
<span style="color: #4f97d7; font-weight: bold;">delete</span> ptr;
</pre>
</div>
<p>
2 通过一个指向派生类的指针，调用第二基类中继承而来的虚函数。在这种情况下，派生类指针必须再次调整，以指向第二个基类子对象。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">Derived</span> *<span style="color: #7590db;">pder</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Derived</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">invokes Base2::mumble()</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pder must be adjusted forward by sizeof( Base1 )</span>
pder-&gt;mumble<span style="color: #4f97d7;">()</span>;
</pre>
</div>
<p>
3 允许一个虚函数的返回值类型有所变化，可能是基类，也可能是派生类。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">Base2</span> *<span style="color: #7590db;">pb1</span> = <span style="color: #4f97d7; font-weight: bold;">new</span> <span style="color: #ce537a; font-weight: bold;">Derived</span>;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">invokes Derived* Derived::clone()</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return must be adjusted to address Base2 subobject</span>
<span style="color: #ce537a; font-weight: bold;">Base2</span> *<span style="color: #7590db;">pb2</span> = pb1-&gt;clone<span style="color: #4f97d7;">()</span>;
</pre>
</div>
<p>
这一节原书讲的很精彩，看原书内容吧<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">4.2.3</span> 虚拟继承下的虚函数</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
这种情况很复杂，没有谈。<br  />
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline59" class="outline-3">
<h3 id="orgheadline59"><span class="section-number-3">4.3</span> 函数的效能</h3>
<div class="outline-text-3" id="text-4-3">
<p>
具体细节看原书吧。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline63" class="outline-3">
<h3 id="orgheadline63"><span class="section-number-3">4.4</span> 指向成员函数的指针</h3>
<div class="outline-text-3" id="text-4-4">
<p>
取一个非静态成员函数的地址，如果该函数为非虚函数，则得到它在内存中的真正地址。然而这个值也不是完全的，它需要被绑定于某个类对象的地址上，才能够<br  />
通过它来调用该函数。<br  />
指向成员函数的指针的声明语法，以及指向成员选择运算符的指针，其作用是作为 this 指针的空间保留者。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp">&#25351;&#21521;&#25104;&#21592;&#20989;&#25968;&#30340;&#25351;&#38024;&#65292;&#20854;&#22768;&#26126;&#35821;&#27861;&#22914;&#19979;&#65306;
<span style="color: #ce537a; font-weight: bold;">double</span>            <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">return type</span>
<span style="color: #4f97d7;">(</span> <span style="color: #a45bad;">Point</span>::*        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">class the function is member</span>
<span style="color: #ce537a; font-weight: bold;">pmf</span> <span style="color: #4f97d7;">)</span>             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">name of pointer to member</span>
<span style="color: #4f97d7;">()</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">argument list</span>

<span style="color: #ce537a; font-weight: bold;">&#23450;&#20041;&#21021;&#22987;&#21270;&#25104;&#21592;&#20989;&#25968;&#25351;&#38024;</span>
<span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #4f97d7;">(</span><span style="color: #a45bad;">Point</span>::*coord<span style="color: #4f97d7;">)()</span> = &amp;<span style="color: #a45bad;">Point</span>::x;

&#36890;&#36807;&#25351;&#21521;&#25104;&#21592;&#20989;&#25968;&#30340;&#25351;&#38024;&#26469;&#35843;&#29992;&#25104;&#21592;&#20989;&#25968;
<span style="color: #4f97d7;">(</span> origin.*coord <span style="color: #4f97d7;">)()</span>;   &#25110;&#32773;
<span style="color: #4f97d7;">(</span> ptr-&gt;*coord <span style="color: #4f97d7;">)()</span>;     &#25110;&#32773;
<span style="color: #4f97d7;">(</span> coord <span style="color: #4f97d7;">)(</span> &amp; origin <span style="color: #4f97d7;">)</span>; &#25110;&#32773;
<span style="color: #4f97d7;">(</span> coord <span style="color: #4f97d7;">)(</span> ptr <span style="color: #4f97d7;">)</span>;

<span style="color: #a45bad;">Tips</span>:
&#21462;&#26500;&#36896;&#20989;&#25968;&#21644;&#26512;&#26500;&#20989;&#25968;&#30340;&#22320;&#22336;&#26159;&#19981;&#34987;&#20801;&#35768;&#30340;&#65292;&#26080;&#27861;&#36890;&#36807;&#32534;&#35793;&#12290;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#19979;&#38754;&#20195;&#30721;&#26080;&#27861;&#36890;&#36807;&#32534;&#35793;</span>
printf<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"Point::Point = %p\n"</span>, &amp;<span style="color: #a45bad;">Point</span>::Point<span style="color: #4f97d7;">)</span>;
printf<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">"Point::~Point = %p\n"</span>, &amp;<span style="color: #a45bad;">Point</span>::~Point<span style="color: #4f97d7;">)</span>;
</pre>
</div>

<p>
使用一个成员函数指针，如果并不用于 virtual 函数、多重继承、虚基类等情况的话，并不会比使用一个非成员函数指针的成本更高。<br  />
</p>
</div>
<div id="outline-container-orgheadline60" class="outline-4">
<h4 id="orgheadline60"><span class="section-number-4">4.4.1</span> 支持指向虚成员函数的指针</h4>
<div class="outline-text-4" id="text-4-4-1">
<p>
对一个 virtual 成员函数取地址，所能获得的只是一个索引值。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline61" class="outline-4">
<h4 id="orgheadline61"><span class="section-number-4">4.4.2</span> 多重继承下，指向成员函数的指针</h4>
<div class="outline-text-4" id="text-4-4-2">
<p>
为了让成员函数的指针也能够支持多重继承和虚拟继承，设计了下面结构体<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">fully general structure to support</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">pointer to member functions under MI</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">__mptr</span> <span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">delta</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this &#25351;&#38024;&#30340; offset &#20540;</span>
   <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">index</span>;               <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34394;&#34920;&#32034;&#24341;</span>
   <span style="color: #4f97d7; font-weight: bold;">union</span> <span style="color: #bc6ec5;">{</span>
      <span style="color: #ce537a; font-weight: bold;">ptrtofunc</span>  <span style="color: #7590db;">faddr</span>;     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#38750;&#34394;&#25104;&#21592;&#20989;&#25968;&#22320;&#22336;</span>
      <span style="color: #ce537a; font-weight: bold;">int</span>        <span style="color: #7590db;">v_offset</span>;  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#34394;&#22522;&#31867;&#65288;&#25110;&#22810;&#37325;&#32487;&#25215;&#20013;&#31532;&#20108;&#25110;&#21518;&#32487;&#30340;&#65289;&#22522;&#31867;&#30340; vptr &#20301;&#32622;</span>
   <span style="color: #bc6ec5;">}</span>;
<span style="color: #4f97d7;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62"><span class="section-number-4">4.4.3</span> 指向成员函数之指针的效率</h4>
<div class="outline-text-4" id="text-4-4-3">
<p>
具体细节看原书吧<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline66" class="outline-3">
<h3 id="orgheadline66"><span class="section-number-3">4.5</span> Inline Function</h3>
<div class="outline-text-3" id="text-4-5">
<p>
把存取函数声明为 inline，就可以保持直接存取成员的高效率，而且兼顾了函数的封装性。<br  />
关键词 inline 只是一项请求。如果这项请求被编译器接受，编译器就必须认为它可以用一个表达式合理地将这个函数扩展开来。<br  />
</p>
</div>
<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64"><span class="section-number-4">4.5.1</span> 形式参数</h4>
<div class="outline-text-4" id="text-4-5-1">
<p>
面对“会带有副作用的实际参数”，通常都需要引入临时性对象。如果实际参数是一个常量表达式，在替换之前先完成求值操作，后继 inline 替换，就直接将<br  />
常量绑上去。如果既不是个常量表达式，也不是个带有副作用的表达式，就直接替换之。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">inline</span> <span style="color: #ce537a; font-weight: bold;">int</span>
<span style="color: #bc6ec5; font-weight: bold;">bar</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">minval</span>;
   <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">val1</span> = <span style="color: #a45bad;">1024</span>;
   <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">val2</span> = <span style="color: #a45bad;">2048</span>;
<span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">(1)*/</span>minval = min<span style="color: #bc6ec5;">(</span> val1, val2 <span style="color: #bc6ec5;">)</span>;
<span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">(2)*/</span>minval = min<span style="color: #bc6ec5;">(</span> <span style="color: #a45bad;">1024</span>, <span style="color: #a45bad;">2048</span> <span style="color: #bc6ec5;">)</span>;
<span style="color: #2aa1ae; background-color: #292e34;">/*</span><span style="color: #2aa1ae; background-color: #292e34;">(3)*/</span>minval = min<span style="color: #bc6ec5;">(</span> foo<span style="color: #2d9574;">()</span>, bar<span style="color: #2d9574;">()</span>+<span style="color: #a45bad;">1</span> <span style="color: #bc6ec5;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">return</span> minval;
<span style="color: #4f97d7;">}</span>

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">(1) simple argument substitution</span>
minval = val1 &lt; val2 ? val1 : val2;

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">(2)     constant folding following substitution</span>
minval = <span style="color: #a45bad;">1024</span>;

<span style="color: #2aa1ae; background-color: #292e34;">//</span><span style="color: #2aa1ae; background-color: #292e34;">(3)     side-effects and introduction of temporary</span>
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">t1</span>;
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">t2</span>;
minval =
   <span style="color: #4f97d7;">(</span> t1 = foo<span style="color: #bc6ec5;">()</span> <span style="color: #4f97d7;">)</span>, <span style="color: #4f97d7;">(</span> t2 = bar<span style="color: #bc6ec5;">()</span> + <span style="color: #a45bad;">1</span> <span style="color: #4f97d7;">)</span>,
   t1 &lt; t2 ? t1 : t2;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">4.5.2</span> 局部变量</h4>
<div class="outline-text-4" id="text-4-5-2">
<p>
一般而言，inline 函数中的每个局部变量都必须被放在函数调用的一个封闭区段中，拥有一个独一无二的名称。如果 inline 函数以单一表达式扩展多次，<br  />
那么每次扩展都需要自己的一组局部变量。如果 inline 函数以分离的多个式子被扩展多次，那么只需要一组局部变量，就可以重复使用。<br  />
</p>

<p>
参数带有副作用，或是以一个单以表达式做多重调用，或是在 inline 函数中有多个局部变量，都会产生临时性对象。此外，inline 中再有 inline，可<br  />
能会使一个表面上看起来平凡的 inline 却因其连锁复杂度而没有办法扩展开来。inline 函数提供了强而又力的工具，然而，与 non-inline 函数比起来，<br  />
它们需要更加小心地处理。<br  />
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline77" class="outline-2">
<h2 id="orgheadline77"><span class="section-number-2">5</span> Semantics of Construction,Destruction,and Copy</h2>
<div class="outline-text-2" id="text-5">
<p>
可以定义和调用一个纯虚函数，不过它只能被静态地调用，不能经由虚拟机制调用。<br  />
</p>
<pre class="example">
虽然可以定义和调用一个纯虚函数，但是最好不要这样做，让纯虚函数保持其接口的语义，即指定子类必须需要重新实现的功能。
如果需要有默认实现，那么只用虚函数就可以了。然后将抽象类的析构函数指定为纯虚函数，提供默认实现。
</pre>
</div>
<div id="outline-container-orgheadline71" class="outline-3">
<h3 id="orgheadline71"><span class="section-number-3">5.1</span> 无继承情况下的对象构造</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-orgheadline68" class="outline-4">
<h4 id="orgheadline68"><span class="section-number-4">5.1.1</span> Plain Ol' Data</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
这种情况下构造函数和析构函数要么不会被合成出来，要么不会被调用。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline69" class="outline-4">
<h4 id="orgheadline69"><span class="section-number-4">5.1.2</span> 抽象数据类型</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
这种情况下构造函数会被调用。析构函数没有被合成出来，也不会被调用。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline70" class="outline-4">
<h4 id="orgheadline70"><span class="section-number-4">5.1.3</span> 包含虚函数</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
这种情况下可能会生成 copy 构造函数、copy 赋值操作符。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline73" class="outline-3">
<h3 id="orgheadline73"><span class="section-number-3">5.2</span> 继承体系下的对象构造</h3>
<div class="outline-text-3" id="text-5-2">
<p>
定义一个类的对象时，实际发生了什么事情？如果类有一个构造函数，它会被调用。<br  />
构造函数的调用真正伴随了什么？编译器会扩充每一个构造函数，扩充程度和类的继承体系有关。一般而言扩充操作大致如下：<br  />
1 记录在成员初始化列表中的数据成员初始化操作会被放进构造函数中，并以成员的声明顺序为顺序。<br  />
2 如果有一个成员并没有出现在成员初始化列表中，它有一个默认构造函数，那么该默认构造函数会被调用。<br  />
3 在那之前，如果类对象有虚表指针，它们必须设定初值，指向适当的虚表。<br  />
4 在那之前，所有上一层的基类构造函数必须调用，以基类的声明顺序为顺序<br  />
4.1 如果基类被列于成员初始化列表中，那么任何明确指定的参数都应该传递过去<br  />
4.2 如果基类没有被列于成员初始化列表中，而它有默认构造函数，那么就调用之。<br  />
4.3 如果基类是多重继承下的第二或后继基类，那么 this 执着必须有所调整。<br  />
5 在那之前，所有虚基类构造函数必须被调用，从左到右，从最深到最浅。<br  />
5.1 如果类被列于成员初始化列表中，那么任何明确指定的参数都应该传递过去。若没有列于成员初始化列表中，有默认构造函数，就调用之。<br  />
5.2 类中的每一个虚基类子对象的偏移量必须在执行期可被存取。<br  />
5.3 如果类对象是 most derived 类(最浅的类)，其构造函数被调用；某些用以支持这个行为的机制必须被放进了。<br  />
</p>
</div>
<div id="outline-container-orgheadline72" class="outline-4">
<h4 id="orgheadline72"><span class="section-number-4">5.2.1</span> vptr 初始化语义</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
vptr 初始化操作在基类构造函数调用完后，但是在程序员提供的代码或成员初始化列表中所列成员初始化操作之前进行。这样可以保证在构造函数中调用虚函数<br  />
可以调用正确的虚函数实体。 但是在构造函数中调用成员函数可能并不安全，因为函数本身可能还得依赖未被设立初值的成员。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline74" class="outline-3">
<h3 id="orgheadline74"><span class="section-number-3">5.3</span> 对象复制语义</h3>
<div class="outline-text-3" id="text-5-3">
<p>
一个类对于默认 copy 赋值操作，在下面情况下不会表现出基于位 copy 的语意：<br  />
1 当类内带一个成员对象，而其类有一个 copy 赋值操作符函数时。<br  />
2 当一个类的基类有一个 copy 赋值操作符函数时。<br  />
3 当一个类声明了任何虚函数（一定不能够 copy 右端类对象的 vptr，因为它可能是一个派生类对象）<br  />
4 当类继承自一个虚基类时。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline75" class="outline-3">
<h3 id="orgheadline75"><span class="section-number-3">5.4</span> 对象的效能</h3>
<div class="outline-text-3" id="text-5-4">
<p>
具体细节看原书吧<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline76" class="outline-3">
<h3 id="orgheadline76"><span class="section-number-3">5.5</span> 对象解构语义</h3>
<div class="outline-text-3" id="text-5-5">
<p>
一个由程序员定义的析构函数被扩展的方式类似于构造函数被扩展的方式，但顺序相反：<br  />
1 如果对象内带一个 vptr，那么首先重设相关的 virtual table<br  />
2 析构函数本身现在被执行，也就是说 vptr 会在程序员的代码执行前被重设。<br  />
3 如果类拥有成员函数对象，而后者拥有析构函数，那么它们会以其声明的相反顺序被调用。<br  />
4 如果有任何直接非虚基类拥有析构函数，那么它们会以其声明的相反顺序被调用。<br  />
5 如果有任何虚基类拥有析构函数，而当前讨论的这个类是最尾端的类，那么它们会以其原来的构造顺序的相反顺序被调用。<br  />
</p>

<p>
和构造函数一样，目前对于析构函数的一种最佳实现策略就是维护两份析构实体：<br  />
1 一个完全对象实体，总是设定好 vptr，并调用虚基类析构函数。<br  />
2 一个虚基类子对象实体，除非在析构函数中调用一个虚函数，否则绝不会调用虚基类析构函数并设置 vptr；<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline85" class="outline-2">
<h2 id="orgheadline85"><span class="section-number-2">6</span> Runtime Semantics</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-orgheadline82" class="outline-3">
<h3 id="orgheadline82"><span class="section-number-3">6.1</span> 对象的构造和解构</h3>
<div class="outline-text-3" id="text-6-1">
<p>
一般而言将对象尽量放置在使用它的那个程序区段附近，这样可以节省不必要的对象产生操作和摧毁操作。<br  />
</p>
</div>
<div id="outline-container-orgheadline78" class="outline-4">
<h4 id="orgheadline78"><span class="section-number-4">6.1.1</span> 全局对象</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
C++保证一定会在 main()函数中第一次用到某个全局对象之前，将该全局对象构造出来，而在 main()函数结束之前把该全局对象销毁掉。如果该全局对象<br  />
有构造函数和析构函数的话，它需要今天的初始化操作和内存释放操作。<br  />
C++程序中所有全局对象都被放置在程序的数据段中。如果明确指定给它一个值，object 将以该值为初值。否则 object 所配置到的内存内容都为 0。<br  />
全局对象的构造函数一直到程序激活时才会实施。必须对一个放置在程序数据段中的对象的初始化表达式做求值，这正是为什么一个 object 需要静态初<br  />
始化的原因。<br  />
支持非类对象的静态初始化，在某种程度上是支持虚基类的一个副产品。<br  />
使用被静态初始化的对象有一些缺点。<br  />
1 如果异常处理被支持，这些对象不能够被放置在 try 区段之内。<br  />
2 为了控制需要跨越模块做静态初始化对象的相依顺序而扯出来的复杂度。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline79" class="outline-4">
<h4 id="orgheadline79"><span class="section-number-4">6.1.2</span> 局部静态对象</h4>
<div class="outline-text-4" id="text-6-1-2">
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">generated temporary static object guard</span>
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Matrix</span> *<span style="color: #7590db;">__0__F3</span> = <span style="color: #a45bad;">0</span> ;
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the C analog to a reference is a pointer</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">identity()'s name is mangled based on signature</span>
<span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Matrix</span>*
<span style="color: #bc6ec5; font-weight: bold;">identity__Fv</span> <span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
   <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #4f97d7; font-weight: bold;">struct</span> <span style="color: #ce537a; font-weight: bold;">Matrix</span> <span style="color: #7590db;">__1mat_identity</span> ;

   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">if the guard is set, do nothing, else</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(a) invoke the constructor: __ct__6MatrixFv</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">(b) set the guard to address the object</span>
   __0__F3
   ? <span style="color: #a45bad;">0</span>
   : <span style="color: #bc6ec5;">(</span>__ct__1MatrixFv <span style="color: #2d9574;">(</span> &amp; __1mat_identity <span style="color: #2d9574;">)</span>,
     <span style="color: #2d9574;">(</span>__0__F3 = <span style="color: #67b11d;">(</span>&amp;__1mat_identity<span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span><span style="color: #bc6ec5;">)</span>;
   ...
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline80" class="outline-4">
<h4 id="orgheadline80"><span class="section-number-4">6.1.3</span> 对象数组</h4>
</div>

<div id="outline-container-orgheadline81" class="outline-4">
<h4 id="orgheadline81"><span class="section-number-4">6.1.4</span> 默认构造和数组</h4>
</div>
</div>

<div id="outline-container-orgheadline83" class="outline-3">
<h3 id="orgheadline83"><span class="section-number-3">6.2</span> new delete 运算符</h3>
</div>
<div id="outline-container-orgheadline84" class="outline-3">
<h3 id="orgheadline84"><span class="section-number-3">6.3</span> 临时性对象</h3>
</div>
</div>
<div id="outline-container-orgheadline89" class="outline-2">
<h2 id="orgheadline89"><span class="section-number-2">7</span> On the Cusp of the Object Model</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-orgheadline86" class="outline-3">
<h3 id="orgheadline86"><span class="section-number-3">7.1</span> 模板</h3>
</div>
<div id="outline-container-orgheadline87" class="outline-3">
<h3 id="orgheadline87"><span class="section-number-3">7.2</span> 异常处理</h3>
</div>
<div id="outline-container-orgheadline88" class="outline-3">
<h3 id="orgheadline88"><span class="section-number-3">7.3</span> 执行期类型识别</h3>
</div>
</div>



<div id="outline-container-orgheadline125" class="outline-2">
<h2 id="orgheadline125"><span class="section-number-2">8</span> Q&amp;A:</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-orgheadline101" class="outline-3">
<h3 id="orgheadline101"><span class="section-number-3">8.1</span> c++中的类型转换有哪些？</h3>
<div class="outline-text-3" id="text-8-1">
</div><div id="outline-container-orgheadline90" class="outline-4">
<h4 id="orgheadline90"><span class="section-number-4">8.1.1</span> 一、类型转换的意义：</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
表达式是否合法取决于操作数的类型，而且合法的表达式其含义也由操作数类型决定。而操作数的类型又可由 C++中的类型转换而改变。因此，类型转换影响着<br  />
表达式的合法性和表达式的结果。<br  />
</p>
</div>
</div>

<div id="outline-container-orgheadline91" class="outline-4">
<h4 id="orgheadline91"><span class="section-number-4">8.1.2</span> 二、什么是类型转换：</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
顾名思义，类型转换就是一种类型值转换为另一种类型值的处理方式。在 C++中定义了内置类型之间的类型转换（即，标准转换，另一种转换被称为类类型转换），<br  />
也允许将某种类型转换为类类型（例如，接受单个形参的构造函数可以将某种类型转换为类类型）或者将类类型转换为某种类型（例如，通过重载转换操作符可以<br  />
将类型转换为某种类型）。需要记住的是<br  />
（1）类类型转换的实现细节需要程序员们自己定义。<br  />
（2）并非所有的类型之间都可以任意转换。<br  />
例如：int a = "haha"; 编译这句代码会产生下面的错误提示信息：test.cpp invalid conversion from `const char*' to `int' 。<br  />
</p>
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-4">
<h4 id="orgheadline100"><span class="section-number-4">8.1.3</span> 三、类型转换分类：</h4>
<div class="outline-text-4" id="text-8-1-3">
</div><ol class="org-ol"><li><a id="orgheadline98"></a>从是否需要在类型转换的地方写代码来使用类型转换，可以将类型转换分为：隐式类型转换、显示转换。<br  /><div class="outline-text-5" id="text-8-1-3-1">
<p>
隐式类型转换——编译器自动实现的类型转换。假设表达式需要某种特定类型的数值，但其操作数却是其他不同的类型，此时如果系统定义了适当的类型转换，<br  />
编译器会自动根据转换规则将该操作数转换为需要的类型。<br  />
显示转换——显示转换也称为强制类型转换，包括以下列名字命名的强制类型转换操作符：static_cast、dynamic_cast、const_cast 和<br  />
reinterpret_cast。<br  />
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline92"></a>隐式转换<br  /><div class="outline-text-6" id="text-8-1-3-1-1">
<p>
何时发生隐式类型转换？<br  />
1、在混合类型的表达式中，其操作数被转换为相同的类型。例如：<br  />
int ival；double dval；<br  />
ival &gt;= dval; //ival converted to double<br  />
2、用作条件的表达式被转换为 bool 类型<br  />
3、用一表达式初始化某个变量，或将一表达式赋值给某个变量，则该表达式被转换为该变量的类型（其实在函数调用中传递参数发生的隐式转换属于初始<br  />
化形参变量发生的类型转换）<br  />
</p>
</div></li>
<li><a id="orgheadline97"></a>显式转换<br  /><div class="outline-text-6" id="text-8-1-3-1-2">
<p>
何时需要显式转换？<br  />
（1）需要覆盖标准转换时，应该使用强制类型转换。例如：<br  />
double dval;<br  />
int ival;<br  />
ival = ival * dval; //首先将 ival 转换 double 型，然后将乘积的结果转换为 int 型<br  />
可以将上面这句代码用下面代码替换：<br  />
ival *= static_cast&lt;int&gt;dval;<br  />
（2）可能存在多种转换时，需要选择一种特定的类型转换。<br  />
</p>
</div>
<ol class="org-ol"><li><a id="orgheadline93"></a>static_cast<br  /><div class="outline-text-7" id="text-8-1-3-1-2-1">
<p>
显式的类型转换，和（type）var 等价。<br  />
</p>
</div></li>
<li><a id="orgheadline94"></a>dynamic_cast<br  /><div class="outline-text-7" id="text-8-1-3-1-2-2">
<p>
dynamic_cast 支持运行时识别指针或引用所指向的对象，将基类类型的指针或引用安全地转换为派生类型<br  />
的指针或引用。<br  />
Tips：<br  />
转换引用时若转换失败会抛出 std::bad_cast 异常<br  />
</p>
</div></li>
<li><a id="orgheadline95"></a>const_cast<br  /><div class="outline-text-7" id="text-8-1-3-1-2-3">
<p>
const_cast ,顾名思义,将转换掉表达式的 const 性质。<br  />
const 只支持指针和引用的转换。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">test_type_cast</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">temp_01</span> = <span style="color: #a45bad;">10</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">int temp_02 = const_cast&lt;int&gt;(temp_01);               //&#32534;&#35793;&#20986;&#38169;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">cout &lt;&lt; "temp_02 = " &lt;&lt; temp_02 &lt;&lt; endl;</span>

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">temp_11</span> = <span style="color: #a45bad;">10</span>;
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">const int temp_12 = const_cast&lt;const int&gt;(temp_11);   //&#32534;&#35793;&#20986;&#38169;</span>
    <span style="color: #2aa1ae; background-color: #292e34;">//    </span><span style="color: #2aa1ae; background-color: #292e34;">cout &lt;&lt; "temp_12 = " &lt;&lt; temp_12 &lt;&lt; endl;</span>

    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span>* <span style="color: #7590db;">temp_21</span> = &amp;temp_01;
    <span style="color: #ce537a; font-weight: bold;">int</span>* <span style="color: #7590db;">temp_22</span> = <span style="color: #4f97d7; font-weight: bold;">const_cast</span>&lt;<span style="color: #ce537a; font-weight: bold;">int</span>*&gt;<span style="color: #bc6ec5;">(</span>temp_21<span style="color: #bc6ec5;">)</span>;
    cout &lt;&lt; <span style="color: #2d9574;">"temp_22 = "</span> &lt;&lt; temp_22 &lt;&lt; endl;

    <span style="color: #ce537a; font-weight: bold;">int</span>* <span style="color: #7590db;">temp_31</span> = &amp;temp_11;
    <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span>* <span style="color: #7590db;">temp_32</span> = <span style="color: #4f97d7; font-weight: bold;">const_cast</span>&lt;<span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">int</span>*&gt;<span style="color: #bc6ec5;">(</span>temp_31<span style="color: #bc6ec5;">)</span>;
    cout &lt;&lt; <span style="color: #2d9574;">"temp_32 = "</span> &lt;&lt; temp_32 &lt;&lt; endl;
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li>
<li><a id="orgheadline96"></a>reinterpret_cast<br  /><div class="outline-text-7" id="text-8-1-3-1-2-4">
<p>
reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。<br  />
</p>
</div></li></ol></li></ol></li>
<li><a id="orgheadline99"></a>从是否需要编写代码来实现类型转换的具体实现细节，可以将类型转换分为：标准转换、类类型转换。<br  /><div class="outline-text-5" id="text-8-1-3-2">
<p>
标准转换——内置类型之间的相互转换。<br  />
类类型转换——到类类型或从类类型的转换。接受一个形参的非显示构造函数定义了到类类型的转换。转换操作符定义了从类类型到操作符所指定类型的转换。<br  />
</p>
</div></li></ol>
</div>
</div>
<div id="outline-container-orgheadline113" class="outline-3">
<h3 id="orgheadline113"><span class="section-number-3">8.2</span> extern 和 static 的区别？</h3>
<div class="outline-text-3" id="text-8-2">
</div><div id="outline-container-orgheadline105" class="outline-4">
<h4 id="orgheadline105"><span class="section-number-4">8.2.1</span> static</h4>
<div class="outline-text-4" id="text-8-2-1">
</div><ol class="org-ol"><li><a id="orgheadline102"></a>改变生命期<br  /><div class="outline-text-5" id="text-8-2-1-1">
<p>
static 将变量声明为 static 会改变变量在内存中的存储（变量被放置在数据段）从而改变变量的生命期（程序结束之前会释放该变量）。<br  />
</p>
</div></li>
<li><a id="orgheadline103"></a>改变作用域/可见性<br  /><div class="outline-text-5" id="text-8-2-1-2">
<p>
static 将变量的可见性限定在其所在的源文件内。所以 static 全局变量只在其所在源文件内可见,不可以在其他源文件中通过 extern 声明静态全局变量来<br  />
存取 static 全局变量。<br  />
</p>
</div></li>
<li><a id="orgheadline104"></a>类静态成员<br  /><div class="outline-text-5" id="text-8-2-1-3">
<p>
static 成员变量属于类，可以通过类或类的对象来存取静态对象。<br  />
static 成员函数没有隐含的 this 指针参数，可以通过类或类的对象来调用静态函数。<br  />
Tips：<br  />
程序中全局静态变量的初始化顺序是不定的。在第一次调用局部静态变量所在函数时,对局部静态变量进行初始化.<br  />
未指定初值的内置类型静态变量被初始化为 0。未指定初始值的类对象在初始化时会调用默认构造函数。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">L6_Test00</span>
<span style="color: #4f97d7;">{</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
    <span style="color: #bc6ec5; font-weight: bold;">L6_Test00</span><span style="color: #bc6ec5;">()</span>
    <span style="color: #bc6ec5;">{</span>
        cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00 -- L6_Test00()"</span> &lt;&lt; endl;
    <span style="color: #bc6ec5;">}</span>
    <span style="color: #bc6ec5; font-weight: bold;">L6_Test00</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">a</span><span style="color: #bc6ec5;">)</span>
    <span style="color: #bc6ec5;">{</span>
        m_value = a;
        cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00 -- L6_Test00(int a)"</span> &lt;&lt; endl;
    <span style="color: #bc6ec5;">}</span>
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">Print</span><span style="color: #bc6ec5;">()</span>
    <span style="color: #bc6ec5;">{</span>
        cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00::Print"</span> &lt;&lt; endl;
    <span style="color: #bc6ec5;">}</span>
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">ivalue</span>;
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">fvalue</span>;

    <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">m_value</span>;
<span style="color: #4f97d7;">}</span>;
<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #a45bad;">L6_Test00</span>::<span style="color: #7590db;">ivalue</span>;
<span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #a45bad;">L6_Test00</span>::<span style="color: #7590db;">fvalue</span> = <span style="color: #a45bad;">2</span>.<span style="color: #a45bad;">0</span>;
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">L6_Test00</span> <span style="color: #7590db;">l6_obj1</span>;
<span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">L6_Test00</span> <span style="color: #bc6ec5; font-weight: bold;">l6_obj2</span><span style="color: #4f97d7;">(</span><span style="color: #a45bad;">3</span><span style="color: #4f97d7;">)</span>;

<span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">TestLesson6</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">bool</span> <span style="color: #7590db;">isRun</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7;">{</span>
    <span style="color: #4f97d7; font-weight: bold;">if</span><span style="color: #bc6ec5;">(</span><span style="color: #a45bad;">!</span>isRun<span style="color: #bc6ec5;">)</span> <span style="color: #4f97d7; font-weight: bold;">return</span>;

    cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00::ivalue = "</span> &lt;&lt; <span style="color: #a45bad;">L6_Test00</span>::ivalue &lt;&lt; endl;
    cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00::fvalue = "</span> &lt;&lt; <span style="color: #a45bad;">L6_Test00</span>::fvalue &lt;&lt; endl;
    <span style="color: #4f97d7; font-weight: bold;">static</span> <span style="color: #ce537a; font-weight: bold;">L6_Test00</span> <span style="color: #7590db;">temp</span>;
    <span style="color: #a45bad;">L6_Test00</span>::ivalue = <span style="color: #a45bad;">10</span>;
    cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00::ivalue = "</span> &lt;&lt; <span style="color: #a45bad;">L6_Test00</span>::ivalue &lt;&lt; endl;
    temp.ivalue = <span style="color: #a45bad;">20</span>;
    cout &lt;&lt; <span style="color: #2d9574;">"L6_Test00::ivalue = "</span> &lt;&lt; <span style="color: #a45bad;">L6_Test00</span>::ivalue &lt;&lt; endl;

    cout &lt;&lt; <span style="color: #2d9574;">"l6_obj1.m_value = "</span> &lt;&lt; l6_obj1.m_value &lt;&lt; endl;
    cout &lt;&lt; <span style="color: #2d9574;">"l6_obj2.m_value = "</span> &lt;&lt; l6_obj2.m_value &lt;&lt; endl;
    <span style="color: #a45bad;">L6_Test00</span>::Print<span style="color: #bc6ec5;">()</span>;
<span style="color: #4f97d7;">}</span>
<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#36755;&#20986;&#32467;&#26524;&#65306;</span>
L6_Test00 -- L6_Test00<span style="color: #4f97d7;">()</span>
L6_Test00 -- L6_Test00<span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">a</span><span style="color: #4f97d7;">)</span>
<span style="color: #a45bad;">L6_Test00</span>::ivalue = <span style="color: #a45bad;">0</span>
<span style="color: #a45bad;">L6_Test00</span>::fvalue = <span style="color: #a45bad;">2</span>
L6_Test00 -- L6_Test00<span style="color: #4f97d7;">()</span>
<span style="color: #a45bad;">L6_Test00</span>::ivalue = <span style="color: #a45bad;">10</span>
<span style="color: #a45bad;">L6_Test00</span>::ivalue = <span style="color: #a45bad;">20</span>
l6_obj1.m_value = <span style="color: #a45bad;">0</span>
l6_obj2.m_value = <span style="color: #a45bad;">3</span>
<span style="color: #a45bad;">L6_Test00</span>::Print
</pre>
</div>
</div></li></ol>
</div>
<div id="outline-container-orgheadline112" class="outline-4">
<h4 id="orgheadline112"><span class="section-number-4">8.2.2</span> extern</h4>
<div class="outline-text-4" id="text-8-2-2">
</div><ol class="org-ol"><li><a id="orgheadline106"></a>声明变量<br  /><div class="outline-text-5" id="text-8-2-2-1">
<p>
extern 用来声明一个变量。也就是说指明该变量是在其他地方定义的。<br  />
Tips：<br  />
任何带有初始化操作的声明都是定义。<br  />
extern int iValue = 10;  // 定义了一个变量 iValue 并初始化其值为 10<br  />
在函数内部不允许声明和定义同时出现<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">test</span><span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7;">{</span>
  <span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iValue1</span> = <span style="color: #a45bad;">10</span>; <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25253;&#38169;</span>
  <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iValue2</span> = <span style="color: #a45bad;">11</span>;
  <span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iValue2</span>;      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25253;&#38169;</span>
  <span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iValue3</span>;
  <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">iValue3</span>;             <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#25253;&#38169;</span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li>
<li><a id="orgheadline107"></a>声明 c++函数<br  /><div class="outline-text-5" id="text-8-2-2-2">
<p>
声明 c++函数可以省略 extern，下面的代码效果是一样的。<br  />
extern void CppFunc(int arg);<br  />
void CppFunc(int arg);<br  />
</p>
</div></li>
<li><a id="orgheadline111"></a>链接指示<br  /><ol class="org-ol"><li><a id="orgheadline108"></a>链接指示有两种形式<br  /><div class="outline-text-6" id="text-8-2-2-3-1">
<p>
第一种形式由关键字 extern 后接字符串字面值，再接“普通”函数声明。字符串字面值指出编写函数所用的语言。<br  />
第二种形式是关键字 extern 后接字符串字面值，再接一对大括号，其中放置多个函数声明。<br  />
当将 #include 指示在复合链接指示的花括号中的时候,假定头文件中的所 有普通函数声明都是用链接指示的语言编写的函数。链接指示可以嵌套,<br  />
所以, 如果头文件包含了带链接指示的函数,该函数的链接不受影响。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">single-statement linkage directive</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #2d9574;">"C"</span> <span style="color: #ce537a; font-weight: bold;">size_t</span> <span style="color: #bc6ec5; font-weight: bold;">strlen</span><span style="color: #4f97d7;">(</span><span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span> *<span style="color: #4f97d7;">)</span>; 

<span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">compound-statement linkage directive</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #2d9574;">"C"</span> <span style="color: #4f97d7;">{</span>
  <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">strcmp</span><span style="color: #bc6ec5;">(</span><span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>*, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>*<span style="color: #bc6ec5;">)</span>; 
  <span style="color: #ce537a; font-weight: bold;">char</span> *<span style="color: #bc6ec5; font-weight: bold;">strcat</span><span style="color: #bc6ec5;">(</span><span style="color: #ce537a; font-weight: bold;">char</span>*, <span style="color: #4f97d7; font-weight: bold;">const</span> <span style="color: #ce537a; font-weight: bold;">char</span>*<span style="color: #bc6ec5;">)</span>;
<span style="color: #4f97d7;">}</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #2d9574;">"C"</span> <span style="color: #4f97d7;">{</span>
<span style="color: #bc6ec5;">  #include</span> <span style="color: #bc6ec5;">&lt;</span><span style="color: #2d9574;">string.h</span><span style="color: #bc6ec5;">&gt;</span>     <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">C functions that manipulate C-style strings </span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li>
<li><a id="orgheadline109"></a>链接指示支持的语言<br  /><div class="outline-text-6" id="text-8-2-2-3-2">
<p>
extern "C" extern "Ada" extern "FORTRAN"<br  />
</p>
</div></li>
<li><a id="orgheadline110"></a>链接指示的运用<br  /><div class="outline-text-6" id="text-8-2-2-3-3">
<p>
在 C++中使用其他语言的函数时，需要通过 extern "xxx"来声明该语言的函数。<br  />
extern "C" {<br  />
  int strcmp(const char*, const char*);<br  />
  char <b>strcat(char</b>, const char*);<br  />
}<br  />
将 C++的函数导出给其他语言使用时，需要在定义该函数时使用 extern "xxx"。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">the calc function can be called from C programs</span>
<span style="color: #4f97d7; font-weight: bold;">extern</span> <span style="color: #2d9574;">"C"</span> <span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #bc6ec5; font-weight: bold;">calc</span><span style="color: #4f97d7;">(</span><span style="color: #ce537a; font-weight: bold;">double</span> <span style="color: #7590db;">dparm</span><span style="color: #4f97d7;">)</span> 
<span style="color: #4f97d7;">{</span> 
  <span style="color: #2aa1ae; background-color: #292e34;">/* </span><span style="color: #2aa1ae; background-color: #292e34;">... */</span>
  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">&#20989;&#25968;&#30340;&#20855;&#20307;&#23454;&#29616;&#30465;&#30053;&#20102;</span>
<span style="color: #4f97d7;">}</span>
</pre>
</div>
</div></li></ol></li></ol>
</div>
</div>
<div id="outline-container-orgheadline114" class="outline-3">
<h3 id="orgheadline114"><span class="section-number-3">8.3</span> 字节对齐是什么？</h3>
</div>
<div id="outline-container-orgheadline115" class="outline-3">
<h3 id="orgheadline115"><span class="section-number-3">8.4</span> 内置类型变量在内存中如何布局？</h3>
</div>
<div id="outline-container-orgheadline116" class="outline-3">
<h3 id="orgheadline116"><span class="section-number-3">8.5</span> 类在内存中的布局是怎样的？</h3>
<div class="outline-text-3" id="text-8-5">
<p>
类包含了静态成员变量、非静态成员变量、静态成员函数、非静态成员函数、虚函数，基类的相关内容，虚基类的相关内容。<br  />
类的静态成员变量、静态成员函数、成员函数，非静态成员函数会有隐含的 this 指针参数。这些函数和 C 语言一样。<br  />
类的虚函数地址会被组织到一个虚函数表中。<br  />
类、基类、虚基类都一样。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline117" class="outline-3">
<h3 id="orgheadline117"><span class="section-number-3">8.6</span> 对象在内存中的布局是怎样的？</h3>
<div class="outline-text-3" id="text-8-6">
<p>
按照继承顺序布局类中的成员变量。<br  />
对于有虚函数的会在对象末尾添加_vptr__X 指针，该指针指向虚函数表。<br  />
对于有虚继承的会在对象末尾添加 bptr 指针，该指针指向虚基类对象地址表。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline118" class="outline-3">
<h3 id="orgheadline118"><span class="section-number-3">8.7</span> 什么时候需要在成员函数中显式使用 this?</h3>
<div class="outline-text-3" id="text-8-7">
<p>
一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；<br  />
另外一种情况是当参数与成员变量名相同时，如 this-&gt;n = n（不能写成 n = n）。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline121" class="outline-3">
<h3 id="orgheadline121"><span class="section-number-3">8.8</span> 关于 inline 的问题</h3>
<div class="outline-text-3" id="text-8-8">
</div><div id="outline-container-orgheadline119" class="outline-4">
<h4 id="orgheadline119"><span class="section-number-4">8.8.1</span> 什么时候使用 inline 什么时候不能使用 inline？</h4>
<div class="outline-text-4" id="text-8-8-1">
<p>
通常对于成员变量的存取操作可以指定为内置函数。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline120" class="outline-4">
<h4 id="orgheadline120"><span class="section-number-4">8.8.2</span> 虚函数是否可以指定为 inline？</h4>
<div class="outline-text-4" id="text-8-8-2">
<p>
可以。<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline122" class="outline-3">
<h3 id="orgheadline122"><span class="section-number-3">8.9</span> memcpy 和 memset 的使用</h3>
<div class="outline-text-3" id="text-8-9">
<p>
只有在类不含任何由编译器产生的内部成员时，memcpy 和 memset 才能有效运行，否则这两个函数会导致那些由编译器产生的内部成员的值被改写。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Shape</span> <span style="color: #4f97d7;">{</span>
<span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">oops: this will overwrite internal vptr!</span>
   <span style="color: #bc6ec5; font-weight: bold;">Shape</span><span style="color: #bc6ec5;">()</span> <span style="color: #bc6ec5;">{</span> memset<span style="color: #2d9574;">(</span> <span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">0</span>, <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #67b11d;">(</span> Shape <span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>;
   <span style="color: #4f97d7; font-weight: bold;">virtual</span> ~<span style="color: #7590db;">Shape</span><span style="color: #2d9574;">()</span>;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">...</span>
<span style="color: #bc6ec5;">}</span>;

&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;
<span style="color: #a45bad;">Shape</span>::<span style="color: #bc6ec5; font-weight: bold;">Shape</span><span style="color: #bc6ec5;">()</span>
<span style="color: #bc6ec5;">{</span>
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">vptr must be set before user code executes</span>
   __vptr__Shape = __vtbl__Shape;
   <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">oops: memset zeros out value of vptr</span>
   memset<span style="color: #2d9574;">(</span> <span style="color: #4f97d7; font-weight: bold;">this</span>, <span style="color: #a45bad;">0</span>, <span style="color: #4f97d7; font-weight: bold;">sizeof</span><span style="color: #67b11d;">(</span> Shape <span style="color: #67b11d;">)</span><span style="color: #2d9574;">)</span>;
<span style="color: #bc6ec5;">}</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline123" class="outline-3">
<h3 id="orgheadline123"><span class="section-number-3">8.10</span> virtual 机制和类对象、类指针、类引用</h3>
<div class="outline-text-3" id="text-8-10">
<p>
virtual 机制包含虚基类 和 虚函数。<br  />
通过对象调用虚函数，或者对虚基类成员进行的存取，都可以优化为直接调用和直接存取。因为每次调用和存取，对象的类型是固定不变的。<br  />
通过指针或引用调用虚函数，或者对虚基类成员进行的存取，不能为直接调用和直接存取。因为每次调用和存取，指针或引用所指的对象的类型可能不同。<br  />
</p>
</div>
</div>
<div id="outline-container-orgheadline124" class="outline-3">
<h3 id="orgheadline124"><span class="section-number-3">8.11</span> Name Mangling</h3>
<div class="outline-text-3" id="text-8-11">
<p>
一般而言，成员的名称前面会被加上类名称，形成独一无二的命名。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Bar</span> <span style="color: #4f97d7;">{</span><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> ival; ...<span style="color: #4f97d7;">}</span>
ival <span style="color: #ce537a; font-weight: bold;">&#21487;&#33021;&#20250;&#34987;&#36716;&#21270;&#20026;</span> <span style="color: #7590db;">ival__3Bar</span>
</pre>
</div>
<p>
对于成员函数，因为其可被重载，所以需要在 name mangling 时加上函数的参数类型。<br  />
需要注意的是 name mangling 不会考虑函数的返回值类型。<br  />
</p>
<div class="org-src-container">

<pre class="src src-cpp"><span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Point</span> <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #ce537a; font-weight: bold;">void</span>  <span style="color: #bc6ec5; font-weight: bold;">x</span><span style="color: #bc6ec5;">(</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">newX</span> <span style="color: #bc6ec5;">)</span>;
   <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">x</span><span style="color: #bc6ec5;">()</span>;
<span style="color: #4f97d7;">}</span>;
&#19978;&#38754;&#30340;&#20195;&#30721;&#20250;&#34987;&#36716;&#25442;&#20026;&#19979;&#38754;&#30340;&#20195;&#30721;
<span style="color: #4f97d7; font-weight: bold;">class</span> <span style="color: #ce537a; font-weight: bold;">Point</span> <span style="color: #4f97d7;">{</span> <span style="color: #4f97d7; font-weight: bold;">public</span>:
   <span style="color: #ce537a; font-weight: bold;">void</span>  <span style="color: #bc6ec5; font-weight: bold;">x__5Point</span><span style="color: #bc6ec5;">(</span> <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #7590db;">newX</span> <span style="color: #bc6ec5;">)</span>;
   <span style="color: #ce537a; font-weight: bold;">float</span> <span style="color: #bc6ec5; font-weight: bold;">x__5Point</span><span style="color: #bc6ec5;">()</span>;
   ...
<span style="color: #4f97d7;">}</span>;
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Dong Guo</p>
<p class="date">Created: 2016-07-16 Sat 03:34</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
