Client-Server

显示程序员所创建的图形的计算机和运行图形程序的计算机可以不同。
Client: 运行图形程序并发出绘图命令的计算机称为客户机
Server: 接收这些绘图命令并执行绘图任务的计算机称为服务器

OpenGL Rendering Pipeline

一.显示列表
任何数据，不论它描述的是几何图元还是像素，都可以保存在显示列表中，供当前或以后使用。当然，
也可以不把数据保存在显示列表中，而是立即对数据进行处理，这种模式也叫做立即模式。当一个显示
列表执行时，保存的数据就从显示列表中取出，就像在立即模式下直接由应用程序发送的那样。

二.求值器
所有的几何图元最终都要通过顶点来描述。参数化曲线和表面最初可能是通过控制点以及叫做基函数的
多项式函数进行描述的。求值器提供了一种方法，根据控制点计算表面的顶点。这种方法是一种多项式
映射，它可以根据控制点产生表面法线、纹理坐标、颜色以及空间坐标值。

三.基于顶点的操作
对于顶点数据，接下来的一个步骤是“基于顶点的操作”，就是把顶点变换为图元。有些类型的顶点数据
（例如空间坐标）是通过一个4*4的浮点矩阵进行变换的。空间坐标从3D世界的一个位置投影到屏幕上
的一个位置。
如果启用了高级特性，这个阶段将更为忙碌。如果使用了纹理，这个阶段还将生成并变换纹理坐标。如
果启用了光照，就需要综合变换后的顶点、表面法线、光源位置、材料属性以及其他光照信息进行光照
计算，产生最终的颜色值。
相对于使用固定功能的顶点处理，从OpenGL 2.0开始，还可以使用顶点着色器来完全控制基于顶点的
操作。如果使用了着色器，基于顶点的操作阶段中的所有操作都会由着色器取代。
在OpenGL 3.1中，所有固定功能的顶点操作都删除了，必须使用顶点着色器。

四. 图元装配
图元装配的一个主要内容就是裁剪，它的任务是消除位于半空间之外的那部分几何图元，这个半空间
是由一个平面定义的。点裁剪就是简单地接受或者拒绝顶点，直线或多边形裁剪则可能需要添加额外
的顶点，具体取决于直线或多边形是如何进行裁剪的。
在有些情况下，接下来需要执行一个叫做透视除法的步骤。它使远处的物体看起来比进处的物体更小
一些。接下来所进行的是视口和深度操作。如果启用了剔除功能并且该图元是一个多边形，那么它就
有可能被剔除测试所拒绝。根据多边形模式，多边形可能画成点的形式或者直线的形式。
这个阶段产生的结果就是完整的几何图元，也就是根据相关的颜色、深度（有时还有纹理坐标值以及
和光栅化处理有关的一些指导信息）进行了变换和裁剪的顶点。

五. 像素操作
在OpenGL渲染管线中，和单路径的几何数据相比，像素数据所经历的流程有所不同。首先，来自系统
内存的一个数组中的像素进行解包，从某种格式（像素的原始格式可能有多种）解包为适当数量的数据
成分。接着，这些数据被缩放、偏移，并根据一副像素图进行处理。处理结果先进行截取，然后或者写
入到纹理内存，或者发送到光栅化阶段。
如果像素数据是从帧缓冲区读取的，就对他们执行像素转换操作（缩放、偏移、映射和截取）。然后，
这些结果被包装为一种适当的格式，并返回到系统内存的一个数组中。
OpenGL有几种特殊的像素复制操作，可以把数据从帧缓冲区复制到帧缓冲区的其他位置或纹理内存中。
这样，在数据写入到纹理内存或者写回到帧缓冲区之前，只需要一道像素转换就可以了。
所介绍的很多像素操作都是固定功能的像素管线的一部分，并且常常会在系统中来回移动大量数据。现
代的图形实现倾向于通过尝试把图形操作集中到位于图形硬件中的内存，从而优化性能。OpenGL 3.0
支持所有这些操作，并且引入了帧缓冲对象来帮助优化这些数据移动，特别是，这些对象可以完全避免
某些数据移动。帧缓冲对象和可编程的片断着色器组合到一起，替代了很多这样的操作（尤其显著的是
那些划分为像素转移的操作），并且大大增强了灵活性。

六. 纹理装配
OpenGL应用程序可以在几何物体上应用纹理图像，使它们看上去更为逼真。如果需要使用多幅纹理图像，
把它们放在纹理对象中是一种明智的做法。这样，就可以很方便地在它们之间进行切换。
几乎所有的OpenGL实现都拥有一些特殊的资源，可以加速纹理的处理（这些资源可能是图形实现中从一
个共享资源池中分配而来的）。为了帮助OpenGL实现高效地管理这些内存资源，优先使用纹理对象来帮助
控制纹理贴图潜在的缓存和定位问题。

七. 光栅化
光栅化就是把几何数据和像素数据转换为片断的过程。每个片断方块对应于帧缓冲区中的一个像素。把顶点
连接起来形成直线或者计算填充多边形内部像素时，需要考虑直线和多边形的点画模式、直线的宽度、点
的大小、着色模型以及用于支持抗锯齿处理的覆盖计算。每个片断方块都将具有各自的颜色和深度值。
栅格化是将矢量图形格式表示的图像转换成栅格图像以用于显示器或者打印机输出的过程。

八. 片断操作
在数据实际存储到帧缓冲区之前，要执行一系列的操作。这些操作可能会修改甚至丢弃这些片断。所有这些
操作都可以启用或禁用。
第一个可能执行的操作是纹理处理。在纹理内存中为每个片断生成一个纹理单元(texel,也就是纹理元素)
，并且应用到这个片断上。接下来，组合主颜色和辅助颜色，可能还会应用一次雾计算。如果应用程序使
用了片断着色器，前面这三个操作可能都在着色器中完成。
前面的操作生成了最终的颜色和深度之后，如果有效，执行可用的剪裁测试、alpha测试、模板测试和深度
缓冲区测试（深度缓冲区实际是隐藏面消除）。某种可用的测试的失败将会终止片断方块的继续处理。随后，
将要执行的可能是混合、抖动、逻辑操作以及很据一个位掩码的屏蔽操作。最后，经过完整处理的片断就被
绘制到适当的缓冲区，最终成为一个像素并到达它最终栖息地。























